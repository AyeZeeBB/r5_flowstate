untyped

globalize_all_functions

struct{
	array<var> recordingAnims
}file

void function RecordingAnimationTest()
{
	entity player = gp()[0]
	vector initialpos = player.GetOrigin()
	vector initialang = player.GetAngles()
	player.StartRecordingAnimation(initialpos, initialang)
	Message(player, "RECORDING MOVEMENT", "", 1.5)
	wait 5
	file.recordingAnims.append( player.StopRecordingAnimation() )
	var anim = file.recordingAnims[file.recordingAnims.len()-1]
	asset playermodel = player.GetModelName()
	WaitFrame()
	Message(player, "PLAYING MOVEMENT", "", 1.5)
	printt(anim) //userdata
	while(true)
	{
		entity dummy = CreatePropDynamic( playermodel, initialpos, initialang, SOLID_BBOX, 99999 )
		dummy.PlayRecordedAnimation( anim, initialpos, initialang, 0.5 )
		//dummy.SetRecordedAnimationPlaybackRate(1.5) //spedup lol
		wait GetRecordedAnimationDuration( anim )
		if(IsValid(dummy))
		dummy.Destroy()
	}
}

void function CreateGravitationalForce( )
{
	entity point_push = CreateEntity( "point_push" )
	point_push.kv.spawnflags = 31
	point_push.kv.enabled = 1
	point_push.kv.magnitude = 50
	point_push.kv.radius = 150
	point_push.SetOrigin( gp()[0].GetOrigin() )//+ gp()[0].GetForwardVector()*250 )
	DispatchSpawn( point_push )
	point_push.Fire( "Enable" )
	// point_push.Fire( "Kill", "", 0.2 )
}

void function StartFightAgainsYourselfChallenge()
{
	entity player = gp()[0]
	entity decoy = player.CreateMimicPlayerDecoy( 180 )
	decoy.SetOrigin(player.GetOrigin() + player.GetForwardVector()*200)
	decoy.SetFriendlyFire( true )
	decoy.SetMaxHealth( 100 )
	decoy.SetHealth( 100 )
	SetObjectCanBeMeleed( decoy, true )
	//newDecoy.SetPlayerOneHits( true )
	//SetTargetName(newDecoy, "UltraDecoy")
	// AddEntityCallback_OnPostDamaged( newDecoy, void function( entity newDecoy, var damageInfo ) : ( owner ) {
		// if ( IsValid( owner ) )
			// HoloPiliot_OnDecoyDamaged( newDecoy, owner, damageInfo )
	// }
}

void function PlayRecordedAnim()
{
	
}

function AiUtility_Init()
{
	RegisterSignal( "OnNewOwner" )
	RegisterSignal( "squadInCombat" )
	RegisterSignal( "OnEndFollow" )
	RegisterSignal( "OnStunned" )

}

////////////////////////////////////////////////////////////////////////////////
// Cloaks npc forever (to be used by anim events)
function NpcCloakOn( npc )
{
	//SetCloakDuration( fade in, duration, fade out )
	npc.SetCloakDuration( 2.0, -1, 0 )
	EmitSoundOnEntity( npc, CLOAKED_DRONE_CLOAK_START_SFX )
	EmitSoundOnEntity( npc, CLOAKED_DRONE_CLOAK_LOOP_SFX )
	npc.Minimap_Hide( TEAM_IMC, null )
	npc.Minimap_Hide( TEAM_MILITIA, null )
}
////////////////////////////////////////////////////////////////////////////////
// De-cloaks npc
function NpcCloakOff( npc)
{
	npc.SetCloakDuration( 0, 0, 1.5 )
	StopSoundOnEntity( npc, CLOAKED_DRONE_CLOAK_LOOP_SFX )
	npc.Minimap_AlwaysShow( TEAM_IMC, null )
	npc.Minimap_AlwaysShow( TEAM_MILITIA, null )
}

int function GetDefaultNPCFollowBehavior( npc )
{
	switch ( npc.GetAIClass() )
	{
		case AIC_FLYING_DRONE:
			return AIF_SUPPORT_DRONE

		case AIC_VEHICLE:
			return AIF_GUNSHIP

		case AIC_TITAN:
		case AIC_TITAN_BUDDY:
			return AIF_TITAN_FOLLOW_PILOT
	}

	return AIF_FIRETEAM
}

void function DieOnPlayerDisconnect( entity npc, entity player )
{
	Assert( IsNewThread(), "Must be threaded off" )
	Assert( npc.IsNPC() )
	Assert( player.IsPlayer() )
	Assert( IsAlive( npc ) )
	Assert( npc.GetBossPlayer() == player )
	Assert( !IsDisconnected( player ) )
	npc.EndSignal( "OnDeath" )

	player.WaitSignal( "OnDestroy" )

	// my boss quit the server!
	if ( IsAlive( npc ) && npc.GetBossPlayer() == player )
		npc.Die()
}

void function NPCFollowsPlayer( entity npc, entity leader )
{
	Assert( IsAlive( npc ) )
	Assert( leader.IsPlayer() )

	npc.SetBossPlayer( leader )

	// team
	SetTeam( npc, leader.GetTeam() )

	if ( IsSpectre( npc ) )
	{
		string squadName = GetPlayerSpectreSquadName( leader )
		SetSquad( npc, squadName )
	}

	thread DieOnPlayerDisconnect( npc, leader )
	#if SP
	Highlight_SetFriendlyHighlight( npc, "friendly_ai" )
	#else
	Highlight_SetOwnedHighlight( npc, "friendly_ai" )
	#endif

	NpcFollowsEntity( npc, leader )
}

void function NPCFollowsNPC( entity npc, entity leader )
{
	Assert( IsAlive( npc ) )
	Assert( IsAlive( leader ) )
	Assert( leader.IsNPC() )

	// team
	SetTeam( npc, leader.GetTeam() )

	// squad
	string squadNameOwner = expect string( leader.Get( "squadname" ) )
	if ( squadNameOwner != "" && leader.GetClassName() == npc.GetClassName() )
		SetSquad( npc, squadNameOwner )

	NpcFollowsEntity( npc, leader )
}

void function NpcFollowsEntity( entity npc, entity leader )
{
	// stop scripted things
	if ( IsMultiplayer() )
		npc.Signal( "StopHardpointBehavior" )

	if ( leader.IsPlayer() && leader.p.followPlayerOverride != null )
	{
		leader.p.followPlayerOverride( npc, leader )
		return
	}

	// follow!
	int followBehavior = GetDefaultNPCFollowBehavior( npc )
	npc.InitFollowBehavior( leader, followBehavior )
	npc.DisableBehavior( "Assault" )
	npc.DisableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_USE_SHOOTING_COVER )
	npc.EnableBehavior( "Follow" )
}


/////////////////////////////////////////////////////////////////////////////////////////////////
bool function HasEnemyWithinDist( entity npc, float dist )
{
	float distSq = dist * dist

	array<entity> enemies
	entity closestEnemy = npc.GetClosestEnemy()
	if ( closestEnemy )
		enemies.append( closestEnemy )

	entity currentEnemy = npc.GetEnemy()
	if ( currentEnemy && currentEnemy != closestEnemy )
		enemies.append( currentEnemy )

	if ( !enemies.len() )
		return false

	vector origin = npc.GetOrigin()
	foreach ( enemy in enemies )
	{
		if ( DistanceSqr( origin, enemy.GetOrigin() ) < distSq )
			return true
	}

	return false
}

SpawnPointFP function FindSpawnPointForNpcCallin( entity npc, asset model, string anim )
{
	float yaw = npc.EyeAngles().y

	vector npcView 				= AnglesToForward( npc.EyeAngles() )
	FlightPath flightPath 		= GetAnalysisForModel( model, anim )

	CallinData drop
	InitCallinData( drop )
	SetCallinStyle( drop, eDropStyle.NEAREST_YAW_FALLBACK )
	SetCallinOwnerEyePos( drop, npc.EyePosition() )
	drop.dist 			= 800
	drop.origin 		= npc.GetOrigin() + npcView * 250
	drop.yaw 			= yaw

	vector angles = Vector( 0, yaw, 0 )
 	SpawnPointFP spawnPoint = GetSpawnPointForStyle( flightPath, drop )
	if ( spawnPoint.valid )
		return spawnPoint

	//if it didn't find one where he was looking - try near him
	drop.origin 		= npc.GetOrigin()
	spawnPoint = GetSpawnPointForStyle( flightPath, drop )

	return spawnPoint
}

function WaitForSquadInCombat( squad )
{
	local master = {}

	//when the thread ends, let child threads now
	OnThreadEnd(
		function() : ( master )
		{
			Signal( master, "OnDestroy" )
		}
	)

	// this internal function keeps track of each guy
	local combatTracker =
		function( guy, master )
		{
			expect entity( guy )
			expect entity( master )

			EndSignal( master, "OnDestroy" )
			EndSignal( guy, "OnDeath", "OnDestroy" )
			if ( !IsAlive( guy ) )
				return

			while ( guy.GetNPCState() != "combat" )
				guy.WaitSignal( "OnStateChange" )

			Signal( master, "squadInCombat" )
		}

	foreach ( guy in squad )
	{
		thread combatTracker( guy, master )
	}

	WaitSignal( master, "squadInCombat" )
}

function WaitForNpcInCombat( npc )
{
	while ( npc.GetNPCState() != "combat" )
		npc.WaitSignal( "OnStateChange" )
}

int function GetNpcHullType( entity npc )
{
	string aiSettings = npc.GetAISettingsName()
	return int ( Dev_GetAISettingByKeyField_Global( aiSettings, "HullType" ) )
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
// "SPAWN AI" DEV MENU Fuctions
//////////////////////////////////////////////////////////////////////////////////////////////////////
const float CROSSHAIR_VERT_OFFSET = 32

vector function GetPlayerCrosshairOriginRaw( entity player )
{
	vector angles = player.EyeAngles()
	vector forward = AnglesToForward( angles )
	vector origin = player.EyePosition()

	vector start = origin
	vector end = origin + forward * 50000
	TraceResults result = TraceLine( start, end )
	vector crosshairOrigin = result.endPos

	return crosshairOrigin
}

vector function GetPlayerCrosshairOrigin( entity player )
{
	return (GetPlayerCrosshairOriginRaw( player ) + Vector( 0, 0, CROSSHAIR_VERT_OFFSET ))
}

void function DEV_MoveToAllAINodes( float delay = 0.0, int loglevel = 0 )
{
	thread function() : ( delay, loglevel )
	{
		printt( "++++--------------------------------------------------------------------------------------------------------------------------++++" )
		printt( ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DEBUGGING AI NODEGRAPH DATA <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<" )
		printt( "++++--------------------------------------------------------------------------------------------------------------------------++++" )
		for( int cIndex = 0; cIndex < NavMeshNode_GetNodeCount(); cIndex++ )
		{
			wait delay
			vector cOrigin = NavMeshNode_GetNodePos( cIndex )

			GetPlayerArray()[0].SetOrigin( cOrigin )

			if ( loglevel == 1 )
			{
				printt( "Index: " + cIndex )
			}
			else if ( loglevel > 1 )
			{
				int nIndex =  NavMeshNode_GetNearestNodeToPos( OriginToGround( cOrigin ) )
				vector nOrigin
				if ( nIndex != -1 )
				{
					nOrigin = NavMeshNode_GetNodePos( nIndex )
				}
				printt( "<<<<<***********************************************************>>>>>" )
				printt( "Current index    : " + cIndex )
				printt( "Current position : " + cOrigin )
				printt( "Nearest index    : " + nIndex )
				printt( "Nearest position : " + nOrigin )
			}
		}
		printt( "++++--------------------------------------------------------------------------------------------------------------------------++++" )
		printt( "++++--------------------------------------------------------------------------------------------------------------------------++++" )
	}()
}
    
    // C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D 
    
    entity function CreateEditorPropZero(asset a, vector pos, vector ang, bool mantle = false, float fade = 5000, int realm = -1)
    {
		//########################################
		//d8888b. d8888b.  .d88b.  d8888b. .d8888. 
		//88  `8D 88  `8D .8P  Y8. 88  `8D 88'  YP 
		//88oodD' 88oobY' 88    88 88oodD' `8bo.   
		//88~~~   88`8b   88    88 88~~~     `Y8b. 
		//88      88 `88. `8b  d8' 88      db   8D 
		//88      88   YD  `Y88P'  88      `8888Y'
		//######################################## 		
    	entity e = CreatePropDynamic(a,pos,ang,SOLID_VPHYSICS,fade)
    	e.kv.fadedist = fade
		e.kv.rendermode = 0
		e.kv.renderamt = 1
		e.kv.solid = 6
		e.kv.CollisionGroup = TRACE_COLLISION_GROUP_PLAYER
    	if(mantle) e.AllowMantle()
    
    	if (realm > -1) {
    		e.RemoveFromAllRealms()
    		e.AddToRealm(realm)
    	}
    	string positionSerialized = pos.x.tostring() + "," + pos.y.tostring() + "," + pos.z.tostring()
    	string anglesSerialized = ang.x.tostring() + "," + ang.y.tostring() + "," + ang.z.tostring()
    
    	e.SetScriptName("editor_placed_prop")
    	e.e.gameModeId = realm
    
    	//printl("[editor]" + string(a) + ";" + positionSerialized + ";" + anglesSerialized + ";" + realm)
    
    	return e
    }
    
    // C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D 
    
    entity function CreateEditorEntity(asset entity_name, vector pos, vector ang)
    {

	  //####################################################################
	  //d88888b d8b   db d888888b d888888b d888888b d888888b d88888b .d8888. 
	  //88'     888o  88 `~~88~~'   `88'   `~~88~~'   `88'   88'     88'  YP 
	  //88ooooo 88V8o 88    88       88       88       88    88ooooo `8bo.   
	  //88~~~~~ 88 V8o88    88       88       88       88    88~~~~~   `Y8b. 
	  //88.     88  V888    88      .88.      88      .88.   88.     db   8D 
	  //Y88888P VP   V8P    YP    Y888888P    YP    Y888888P Y88888P `8888Y'  Written by Zer0Bytes#4428
	  //####################################################################

      array<string> weapons = ["mp_weapon_vinson", "mp_weapon_mastiff", "mp_weapon_energy_shotgun", "mp_weapon_lstar"] 
      string randomWeapon = weapons[RandomInt(weapons.len())]
      entity result
    
      switch (string(entity_name))  // not the best way of doing this idk
      {
    
        case "npc_dummie":
        entity dummie = CreateDummy( TEAM_UNASSIGNED, pos, ang )
        SetSpawnOption_Alert(dummie)
    	DispatchSpawn( dummie )
        dummie.SetSkin(RandomInt(6))
        dummie.GiveWeapon(randomWeapon, WEAPON_INVENTORY_SLOT_ANY)
    	result = dummie
        break
    
        case "npc_dummie_ignore":  // unkillable dummies
        entity ent_npc = CreateEntity( "npc_dummie" )
        SetSpawnOption_AISettings( ent_npc, "npc_dummie_combat" )
        ent_npc.SetOrigin( pos )
        ent_npc.SetAngles( ang )
        SetTeam(ent_npc,TEAM_IMC | TEAM_MILITIA)
        DispatchSpawn( ent_npc ) // spawn entity
        ent_npc.SetDamageNotifications( false )
        ent_npc.NotSolid()
        ent_npc.EnableNPCFlag( NPC_IGNORE_ALL ) // to make them not give a shit
        ent_npc.SetSkin(RandomInt(6))
    	result = ent_npc
        break
    
        case "ent_lootbin":
        entity ent_lootbin = CreateLootBin(pos,ang)
        SetTargetName( ent_lootbin, "LootBin" )
        ent_lootbin.SetOrigin( pos )
        ent_lootbin.SetAngles( ang )
    	result = ent_lootbin
        break
    
        case "ent_singleDoor": // single door
    	entity singleDoor = CreateEntity("prop_door")
    	singleDoor.SetValueForModelKey(FIRINGRANGE_DOOR_ASSET)
    	singleDoor.SetOrigin( pos )
    	singleDoor.SetAngles( ang - <0,90,0>)
    	DispatchSpawn(singleDoor)
        break
    
        case "ent_doubledoor": // double door
        entity DoorLeft = CreateEntity("prop_door")
    	DoorLeft.SetValueForModelKey(FIRINGRANGE_DOOR_ASSET)
    	DoorLeft.SetAngles(ang - <0,90,0>)
    	DoorLeft.SetOrigin(pos + DoorLeft.GetRightVector() * 60)
    	DispatchSpawn(DoorLeft)
    
    	entity DoorRight = CreateEntity("prop_door")
    	DoorRight.SetValueForModelKey(FIRINGRANGE_DOOR_ASSET)
    	DoorRight.SetAngles(ang + <0,90,0>)
    	DoorRight.SetOrigin(pos + DoorRight.GetRightVector() * 60)
    	DoorRight.LinkToEnt( DoorRight )
    	DispatchSpawn(DoorRight)
        break
    
        default:
        break
      }
      string positionSerialized = pos.x.tostring() + "," + pos.y.tostring() + "," + pos.z.tostring()
      string anglesSerialized = ang.x.tostring() + "," + ang.y.tostring() + "," + ang.z.tostring()
    
      //printl("[Load0_Entity]" + string(entity_name) + ";" + positionSerialized + ";" + anglesSerialized + ";")
      result.kv.fadedist = 2000
    
      return result
    }
    
    // C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D 
    
    entity function CreateEditorPilot(asset entity_name,int model_select,int anim_select,vector pos, vector ang)
    {
        //###################################################      
        //d8888b. d888888b db       .d88b.  d888888b .d8888. 
        //88   8D    88'   88      .8P  Y8.  ~~88    88'  YP 
        //88oodD'    88    88      88    88    88     8bo.   
        //88~~~      88    88      88    88    88       Y8b. 
        //88        .88.   88booo.  8b  d8'    88    db   8D 
        //88      Y888888P Y88888P   Y88P'     YP     8888Y' 
        //###################################################  Written by Zer0Bytes#4428                         
                                                          
        //defaults if nothing is selected
        array <asset> model_array = [$"mdl/humans/class/medium/pilot_medium_holo.rmdl"]
        array <string> anim_array = ["mirage_menu_lobby_center_laugh"] // can be pulled from legion and make sure to remove "_0" etc

        Assert( model_select, "No Model Choosen Set to 1!" )
		
        switch (string(entity_name))  // not the best way of doing this idk
        {
	        case "pilot_mirage":
	            model_array = [
				    $"mdl/humans/class/medium/pilot_medium_holo.rmdl"
			    ]
	            anim_array = [
	                "mirage_menu_lobby_center_beard",
	                "mirage_menu_lobby_center_laugh",
	                "mirage_menu_lobby_center_picture",
	                "mirage_menu_lobby_center_magic",
	                "pilot_freefall_emote_backflip",
	                "pilot_freefall_emote_backflip"
				]
            break
        
            case "pilot_gibraltar":
                model_array = [
					$"mdl/humans/class/heavy/pilot_heavy_gibraltar.rmdl"
				]
                anim_array = ["gibraltar_menu_lobby_center_slap"]
            break
        
            case "pilot_support":
                model_array = [
					$"mdl/humans/class/light/pilot_light_support.rmdl"
				]
                anim_array = ["lifeline_idle_UA_dance"]
            break
        
            case "pilot_bloodhound":
                model_array = [
					$"mdl/humans/class/medium/pilot_medium_bloodhound.rmdl"
				]
                anim_array = ["bloodhound_menu_lobby_center_pet"]
            break
        
            case "pilot_bangalore":
                model_array =[
					$"mdl/humans/class/medium/pilot_medium_bangalore.rmdl"
				]
                anim_array = ["bangalore_menu_lobby_center_hair"]
            break
        
            case "pilot_wraith":
                model_array = [
					$"mdl/humans/class/light/pilot_light_wraith.rmdl"
				]
                anim_array = ["wraith_menu_lobby_center_voices"]
            break
        
            case "pilot_pathfinder":
                model_array = [
					$"mdl/humans/class/heavy/pilot_heavy_pathfinder.rmdl"
				]
                anim_array  = ["pathfinder_menu_lobby_center_hopping"]
            break
        
            case "pilot_stim":
                model_array = [
					$"mdl/Humans/class/medium/pilot_medium_stim.rmdl"
				]
                anim_array = ["octane_menu_lobby_center_leg"]
            break
        
            case "pilot_wattson":
                model_array = [
					$"mdl/humans/class/light/pilot_light_wattson.rmdl"
				]
                anim_array = ["wattson_menu_lobby_center_idle"]
            break
        
            case "pilot_caustic":
                model_array = [
					$"mdl/humans/class/heavy/pilot_heavy_caustic.rmdl"
				]
                anim_array = ["caustic_menu_lobby_center_recorder"]
            break
        
            case "pilot_crypto":
                model_array = [
					$"mdl/Humans/class/medium/pilot_medium_crypto.rmdl"
				]
                anim_array = ["crypto_menu_lobby_center_drone"]
            break
        
		    case "npc_tick":
                model_array = [
				$"mdl/robots/drone_frag/drone_frag_loot.rmdl",
			    $"mdl/robots/drone_frag/drone_frag_loot_bf.rmdl",
				$"mdl/robots/drone_frag/drone_frag_loot_halloween.rmdl",
				$"mdl/robots/drone_frag/drone_frag_loot_halloween.rmdl"]

				anim_array = [
				"sd_search_idle",
				"sd_angry_idle",
				"sd_angry_idle",
				"sp_suicide_spectre_explode_stand"]
            break
		    
            default:
            break
        }
        
        asset model
		for (int m;m < model_array.len();m++) // go trough array
		{
			if (model_select == m) // if is selected return anim
			{
				model = model_array[m]
			}
			else
			{
				model = model_array[model_select - 1]
			}
		}
		

        entity ent_prop = CreatePropDynamic(model,pos,ang,SOLID_VPHYSICS,30000)
        ent_prop.kv.fadedist = 30000 // lower fading
        ent_prop.e.gameModeId = -1
        ent_prop.NotSolid() // make the ent's not solid
        ent_prop.StopPhysics()
        ent_prop.kv.fadedist = 2000
        string positionSerialized = pos.x.tostring() + "," + pos.y.tostring() + "," + pos.z.tostring()
        string anglesSerialized = ang.x.tostring() + "," + ang.y.tostring() + "," + ang.z.tostring()
        
        if (anim_select != 0 )
        {
			string anim
			for (int a;a < anim_array.len();a++) // go trough array
			{
				if (anim_select == a) // if is selected return anim
				{
					anim = anim_array[a]
				}
				else
				{
					anim = anim_array[anim_select - 1]
				}
			}

			printl( "[Load0_Pilot]" + string(model) + ";" + anim + ";" + positionSerialized + ";" + anglesSerialized + ";")
            float RotateLoopSpeed =  15
            float smalltick = 0.5
    		float bigtick = 2.5
            switch (anim_select)
            {
    			//tick
    			case 2: // big gold tick
    			if (string(entity_name) == "npc_tick")
    			{
    				ent_prop.SetModelScale(bigtick)
    			}
    			thread PlayAnim( ent_prop, anim )
                break
    
    			case 3: // small spook
    			if (string(entity_name) == "npc_tick")
    			{
                    ent_prop.SetModelScale(smalltick)
    			}
    			thread PlayAnim( ent_prop, anim )
                break
    
    			case 4: // small front flip spook
    			if (string(entity_name) == "npc_tick")
    			{
                    ent_prop.SetModelScale(smalltick)
    			}
    			thread AnimationLoop( ent_prop, anim, RotateLoopSpeed)
                break
                //tick end 

				case 5: // big boy
				ent_prop.SetModelScale(7.0)
				thread BigMirageRotateLoop(ent_prop,anim,RotateLoopSpeed * 8) // rotation
				break
	
				case 6: // table smol mirages
				ent_prop.SetModelScale(0.5)
				thread PlayAnim( ent_prop, anim )
				thread MiniMirageRotateLoop(ent_prop,RotateLoopSpeed) // rotation
				break
    
                default:
                thread PlayAnim( ent_prop, anim )
                break
            }
        } else{  // 0 - no animation / t-pose
            //printl( "[Load0_Pilot]" + string(model) + ";" + positionSerialized + ";" + anglesSerialized + ";")
    		
    	}
    
    	return ent_prop
    }
    
    // C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D 
    
    array<entity> function ent_ZipLine(vector startPos,vector endPos,bool pathfinder_model)
    {
		//##################################################################
		//d88888D d888888b d8888b. db      d888888b d8b   db d88888b .d8888. 
		//YP  d8'   `88'   88  `8D 88        `88'   888o  88 88'     88'  YP 
		//   d8'     88    88oodD' 88         88    88V8o 88 88ooooo `8bo.   
		//  d8'      88    88~~~   88         88    88 V8o88 88~~~~~   `Y8b. 
		// d8' db   .88.   88      88booo.   .88.   88  V888 88.     db   8D 
		//d88888P Y888888P 88      Y88888P Y888888P VP   V8P Y88888P `8888Y' 
        //################################################################## Written by Zer0Bytes#4428

		vector pathfinder_offset = <0,0,120>
		asset PATHFINDER_ZIP_MODEL = $"mdl/props/pathfinder_zipline/pathfinder_zipline.rmdl"

    	entity zipline_start = CreateEntity( "zipline" )
		entity ent_model_start
    	zipline_start.kv.Material = "cable/zipline.vmt"
    	zipline_start.kv.ZiplineAutoDetachDistance = "160"
		array<entity> ziplineEnts

		if (pathfinder_model)
		{
			ent_model_start = CreateEditorPropZero( PATHFINDER_ZIP_MODEL, startPos, <0,0,0>, true, 50000, -1 )
			zipline_start.SetOrigin( startPos + pathfinder_offset)
			//ent_model_start.SetParent(zipline_start)
		} else
		{
		    zipline_start.SetOrigin( startPos )
		}

    	entity zipline_end = CreateEntity( "zipline_end" )
    	zipline_end.kv.ZiplineAutoDetachDistance = "160"
		entity ent_model_end
    	
		if (pathfinder_model)
		{
			ent_model_end = CreateEditorPropZero( PATHFINDER_ZIP_MODEL, endPos, <0,0,0>, true, 50000, -1 )
			zipline_end.SetOrigin( endPos + pathfinder_offset)
			//ent_model_end.SetParent(zipline_end)
		}else
		{
		    zipline_end.SetOrigin( endPos )
		}

    	zipline_start.LinkToEnt( zipline_end )
    	DispatchSpawn( zipline_start )
    	DispatchSpawn( zipline_end )
    
		if (pathfinder_model)
		{
			ziplineEnts = [ zipline_start, zipline_end ,ent_model_start,ent_model_end]
		}else
		{
			ziplineEnts = [ zipline_start, zipline_end ]
		}
		    
    	return ziplineEnts
    }
    
    // C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D 
    
    entity function GenerateRings(asset ring_MODEL,vector origin,float rotate_speed,float ring_size)
    {
    	//Zer0Bytes#4428
    
        // #########################################
        // d8888b. d888888b d8b   db  d888b  .d8888.
        // 88   8D    88'   888o  88 88' Y8b 88'  YP
        // 88oobY'    88    88V8o 88 88       8bo.  
        // 88 8b      88    88 V8o88 88  ooo    Y8b.
        // 88  88.   .88.   88  V888 88. ~8~ db   8D
        // 88   YD Y888888P VP   V8P  Y888P   8888Y'
        // ######################################### Written by Zer0Bytes#4428
    
        Assert( ring_MODEL != null, "No Ring Asset Selected" )
        Assert( origin != null, "No Origin Set" )
    	int amount_rings = 2 // the amount of rings
    	int ring_size_scaling_begin = 0 // at what ring begin the scaling
    	float ring_size_multiplier = 0.1
    	entity ent_ring
    	for (int i;i < amount_rings;i++) // top spinning rings
    	{
    		
    		origin = origin + <0,0,2048 * i + ring_size_multiplier> // modify the y
    
            for (int j = 0;j < 4;j++) // side duplication
    		{
    			switch(j) 
    			{
    				case 0:  // 180
    				ent_ring = CreateEditorPropZero( ring_MODEL , origin, <0,0,0>, true, -1, -1 )
    			    thread vRotateLoop(ent_ring,rotate_speed, false)
    				break
    				case 1:  // 180
    				ent_ring = CreateEditorPropZero( ring_MODEL, origin, <180,0,0>, true, -1, -1 )
    			    thread vRotateLoop(ent_ring,rotate_speed,false)
    				break
    				case 2:  // 90
    				ent_ring = CreateEditorPropZero( ring_MODEL , origin, <90,0,0>, true, -1, -1 )
    			    thread vRotateLoop(ent_ring,rotate_speed, true)
    				break
    				case 3:  // 90
    				ent_ring = CreateEditorPropZero( ring_MODEL, origin, <-90,0,0>, true, -1, -1 )
    			    thread vRotateLoop(ent_ring,rotate_speed,false)
    				break
    				case 4: // 45
    				ent_ring = CreateEditorPropZero( ring_MODEL , origin, <45,0,0>, true, -1, -1 )
    			    thread vRotateLoop(ent_ring,rotate_speed, true)
    				break
    				case 5: // 45
    				ent_ring = CreateEditorPropZero( ring_MODEL, origin, <-45,0,0>, true, -1, -1 )
    			    thread vRotateLoop(ent_ring,rotate_speed,false)
    				break
    				case 6:  // 22
    				ent_ring = CreateEditorPropZero( ring_MODEL , origin, <22,0,0>, true, -1, -1 )
    			    thread vRotateLoop(ent_ring,rotate_speed, true)
    				break
    				case 7:  // 22
    				ent_ring = CreateEditorPropZero( ring_MODEL, origin, <-22,0,0>, true, -1, -1 )
    			    thread vRotateLoop(ent_ring,rotate_speed,false)
    				break
    
    			}
    			ent_ring.NotSolid()

    			for(int k;k < amount_rings;k++)
    			{
    				ent_ring.kv.renderamt = 255
    				ent_ring.kv.rendermode = 3
    				ent_ring.kv.rendercolor = "255 255 255 255"
    				ent_ring.SetModelScale(ring_size * ring_size_multiplier * i)
    			}
    		}
        }
    	return ent_ring
    }
    
    // C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D 
    
    vector wallz_oldorigin_y
    void function CreateInvisibleWall(asset MODEL,vector origin,vector angles,int amount,float spacesize)
    {
        
        // ##############################################
        // db   d8b   db   d8b   db      db      d88888D 
        // 88   I8I   88 d8   8b 88      88      YP  d8  
        // 88   I8I   88 88ooo88 88      88         d8   
        // Y8   I8I   88 88   88 88      88        d8    
        //  8b d8'8b d8  88   88 88booo  88booo   d8  db 
        //   8b8   8d8   YP   YP Y88888P Y88888P d88888P 
        // ############################################## Written by Zer0Bytes#4428
    
    	Assert( MODEL != null, "No Asset Selected" )
    
        vector add_spacesize
        vector origin_y
        int check
        origin = origin - <0,0,spacesize> 
    
        for (int i;i < amount;i++)
        {
            add_spacesize = <0,0,spacesize> 
            
            if(check != 0) // add to location
            {
                origin_y = origin_y + add_spacesize // next position
            }
            else{
                origin_y = origin + add_spacesize // position
                check = 1
            }
            entity ent_inviswall = CreateEditorPropZero( MODEL , origin_y, angles, true, 200, -1 )
            
            ent_inviswall.kv.renderamt = 255
            ent_inviswall.kv.rendermode = 3
            ent_inviswall.kv.rendercolor = "0 0 0 50"
    	    ent_inviswall.kv.solid = 8 // 0 = no collision, 2 = bounding box, 6 = use vPhysics, 8 = hitboxes only
            ent_inviswall.kv.fadedist = 200
            wallz_oldorigin_y = origin_y
        }
        //wait 0.3
    }
	void function CreateDownWall(asset MODEL,vector origin,vector angles,int amount,float spacesize)
    {
    	Assert( MODEL != null, "No Asset Selected" )
        vector add_spacesize
        vector origin_y
        int check
        origin = origin - <0,0,spacesize> 
    
        for (int i;i < amount;i++)
        {
            add_spacesize = <0,0,spacesize> 
            
            if(check != 0) // add to location
            {
                origin_y = origin_y - add_spacesize // next position
            }
            else{
                origin_y = origin + add_spacesize // position
                check = 1
            }
            entity ent_inviswall = CreateEditorPropZero( MODEL , origin_y, angles, true, 50000, -1 )
        
            wallz_oldorigin_y = origin_y
        }
        //wait 0.3
    }

    void function DEV_TeleportPlayers(vector pos, vector ang) 
    {
        int playersize = GetPlayerArray().len()
        for (int i;i < playersize ;i++)
    	{
            entity player = GetPlayerArray()[i]
    		if(IsValidPlayer(player))
    		{
    		   player.SetOrigin( pos )
    		   player.SetAngles( ang )
               printl("[DEV_Teleport]" + player.GetTargetName() + "["+ string(i) + "]" + ";" + string(pos) + ";" + string(ang)+ ";")
    		}
    	}
    }
    
    void function DEV_ChargePlayers() 
    {
        int playersize = GetPlayerArray().len()
        for (int i;i < playersize ;i++)
    	{
            entity player = GetPlayerArray()[i]
    
    		if(IsValidPlayer(player))
    		{
    			player.GetOffhandWeapon( OFFHAND_INVENTORY )
    		    .SetWeaponPrimaryClipCount( player.GetOffhandWeapon( OFFHAND_INVENTORY ).GetWeaponPrimaryClipCountMax() )
    			player.GetOffhandWeapon( OFFHAND_LEFT )
    			.SetWeaponPrimaryClipCount( player.GetOffhandWeapon( OFFHAND_LEFT ).GetWeaponPrimaryClipCountMax() )
                printl("[DEV_Charger]" + player.GetTargetName() + "["+ string(i) + "]" + ";")
    		}
    		
    	}
    }
    
    void function DEV_StatusPlayers()
    {
        int playersize = GetPlayerArray().len()
        for (int i;i < playersize ;i++)
    	{
    		entity player = GetPlayerArray()[i]
    		if(IsValidPlayer(player))
    		{
                
    		    vector origin = GetPlayerCrosshairOrigin( player )

                printl("["+ player.GetTargetName() + "] ["+ string(i)  + "]-----------------------------")
    		    printl("[Entity]" + player.GetTargetName() + "["+ string(i) + "]" + ";" + string(player.GetOrigin()) + ";" + string(player.GetAngles()))
    		    printl("[LookingAt]" + player.GetTargetName() + "["+ string(i) + "]" + ";" + string(origin))

				printl("[DEV_StatusPlayers] // script DEV_TeleportPlayers(" + string(player.GetOrigin()) + "," + string(player.GetAngles()) + ")" )
    		}
    	}
    }

    // #########################################
    // db       .d88b.   .d88b.  d8888b. .d8888. 
    // 88      .8P  Y8. .8P  Y8. 88  `8D 88'  YP 
    // 88      88    88 88    88 88oodD' `8bo.   
    // 88      88    88 88    88 88~~~     `Y8b. 
    // 88booo. `8b  d8' `8b  d8' 88      db   8D 
    // Y88888P  `Y88P'   `Y88P'  88      `8888Y' 
    // ######################################### Written by Zer0Bytes#4428

    void function RotateLoop(entity ent,float speed,bool rightside)
    {
        vector result
        while(isBrightWaterByZer0)
        {
            if(rightside)
            {
               result =  ent.GetAngles() + <0,-speed,0>
            }
            else{
               result = ent.GetAngles()  + <0,speed,00>
            }
    		ent.SetAngles( result ) // result
          wait 0.00001
        }
    }
    
    void function vRotateLoop(entity ent,float speed,bool rightside)
    {
        vector result
    	float sbase = 2
        while(isBrightWaterByZer0)
        {
            if(rightside)
            {
               result =  ent.GetAngles() -  <speed,-speed, 0>
            }
            else{
               result = ent.GetAngles()  +  <-speed,speed, 0>
            }
    		ent.SetAngles( result ) // result
          wait 0.00001
        }
    }
    
    void function AnimationLoop(entity decoy,string anim,float speed)
    {
        vector result
        while(isBrightWaterByZer0)
        {
          PlayAnim( decoy, anim )
          wait 0.00001
        }
    }

    void function BigMirageRotateLoop(entity decoy,string anim,float speed)
    {
        vector result
        while(isBrightWaterByZer0)
        {
            PlayAnim( decoy, anim )
            if(RandomInt(1))
            {
               result =  decoy.GetAngles() + <speed,0,speed > - <0,speed,0>
            }
            else{
               result = decoy.GetAngles() - <0,0,speed> + <speed,speed,0>
            }
          decoy.SetAngles( result ) // result
          wait 0.00001
        }
    }
    void function MiniMirageRotateLoop(entity decoy,float speed)
    {
        vector result
        while(isBrightWaterByZer0)
        {
            if(RandomInt(1))
            {
               result =  decoy.GetAngles() + <0,0,speed> - <0,speed,0>
            }
            else{
               result = decoy.GetAngles() - <0,0,speed> + <0,speed,0>
            }
          decoy.SetAngles( result ) // result
          wait 0.00001
        }
    }

    // ################
	// d88888b db    db
	// 88'     `8b  d8'
	// 88ooo    `8bd8' 
	// 88~~~    .dPYb. 
	// 88      .8P  Y8.
	// YP      YP    YP    
    // ################ Written by Zer0Bytes#4428
	
    entity function ApplyFX(asset FX,entity ent_prop)
    {
        entity trailFXHandle = StartParticleEffectInWorld_ReturnEntity(GetParticleSystemIndex( FX ), ent_prop.GetOrigin(), ent_prop.GetAngles())
        trailFXHandle.SetParent(ent_prop)
        //ent_prop.kv.renderamt = 100
        //ent_prop.kv.rendermode = 3
        //ent_prop.kv.rendercolor = "255 0 0 50"
    	//ent_prop.kv.solid = 0 // 0 = no collision, 2 = bounding box, 6 = use vPhysics, 8 = hitboxes only
    
        trailFXHandle.FXEnableRenderAlways()
        return trailFXHandle
    }
    
    entity function CreateFX(asset FX,vector Origin,vector Angles)
    {
        entity trailFXHandle = StartParticleEffectInWorld_ReturnEntity(GetParticleSystemIndex( FX ), Origin, Angles)
        trailFXHandle.FXEnableRenderAlways()
        return trailFXHandle
    }
    
// C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D C8888D 
void function DEV_SpawnLootBinAtCrosshair()
{
	entity player = GetPlayerArray()[ 0 ]

	vector origin = GetPlayerCrosshairOrigin( player )
	
	vector org1 = origin
	vector org2 = player.GetOrigin()
	vector vec1 = org2 - org1
	vector angles1 = VectorToAngles( vec1 )
	angles1.x = 0

	entity ent_lootbin = CreateCustomLootBin(origin,angles1, ["mp_weapon_sniper", "mp_weapon_sniper","mp_weapon_sniper"])
	SetTargetName( ent_lootbin, "LootBin" )
	ent_lootbin.SetOrigin( origin )
	ent_lootbin.SetAngles( angles1 )	
}

void function DEV_SpawnDummyAtCrosshair()
{
	entity player = GetPlayerArray()[ 0 ]

	vector origin = GetPlayerCrosshairOrigin( player )
	
	vector org2 = player.GetOrigin()
	vector vec1 = org2 - origin
	vector angles1 = VectorToAngles( vec1 )
	angles1.x = 0

	entity dummy = CreateDummy( 99, origin, angles1 )
	if(GetCurrentPlaylistVarBool( "dummies_agressivedummies", false ))
		SetSpawnOption_AISettings( dummy, "npc_dummie_combat" )
	else 
		SetSpawnOption_AISettings( dummy, "npc_training_dummy" )
	
	int randomShield
	
	if(GetCurrentPlaylistVarBool( "dummies_have_random_shields", true ))
		switch(RandomIntRangeInclusive(1,4)){
			case 1:
				randomShield = 50
				break
			case 2:
				randomShield = 75	
				break
			case 3:
				randomShield = 100	
				break
			case 4:
				randomShield = 130
				break
		}
	else
		randomShield = 75

	DispatchSpawn( dummy )	
	dummy.SetOrigin(origin)
	dummy.SetShieldHealthMax( randomShield )
	dummy.SetShieldHealth( randomShield )
	dummy.SetMaxHealth( 100 )
	dummy.SetHealth( 100 )
	dummy.SetTakeDamageType( DAMAGE_YES )
	dummy.SetDamageNotifications( true )
	dummy.SetDeathNotifications( true )
	dummy.SetValidHealthBarTarget( true )
	SetObjectCanBeMeleed( dummy, true )
	dummy.SetSkin(RandomInt(6))
	dummy.DisableHibernation()
	dummy.SetAngles(angles1)

	// if(!GetCurrentPlaylistVarBool( "dummies_agressivedummies", false ))
		thread PlayAnimOnTrainingDummy(dummy)//, script_mover)
	
    // array<string> weapons = ["mp_weapon_vinson", "mp_weapon_mastiff", "mp_weapon_energy_shotgun", "mp_weapon_lstar"]
    // string randomWeapon = weapons[RandomInt(weapons.len())]
    // dummy.GiveWeapon(randomWeapon, WEAPON_INVENTORY_SLOT_ANY)
}

void function PlayAnimOnTrainingDummy(entity dummy)//, entity script_mover )
{
WaitFrame()

EndSignal(dummy, "OnDeath")

			vector org1 = gp()[0].GetOrigin()
			vector org2 = dummy.GetOrigin()
			vector vec2 = org1 - org2
			vector angles2 = VectorToAngles( vec2 )
			

			array<vector> circleLocations
			
			for(int i = 0; i < 15; i ++)
			{
				float r = float(i) / float(15) * 2 * PI
				vector origin2 = org2 + 50 * <sin( r ), cos( r ), 0.0>
				circleLocations.append(origin2)
			}

entity ai = dummy
int locationindex = 0	
dummy.SetOrigin(circleLocations[locationindex])

while(IsValid(ai))
	{
		
		// int random = RandomIntRangeInclusive(1,10)
		// if(random == 1 || random == 2 || random == 3 || random == 4){
		// //a d strafe

			ai.Anim_PlayOnly( "animseq/humans/class/medium/pilot_medium_bloodhound/mp_pilot_freefall_dive.rseq")//, true, 0.1 ) //Ok this looks easy, but have you seen Activity modifiers being used this way in the code before? ;)
			wait 0.1
			// wait RandomFloatRange(0.04,0.5)
			// ai.Anim_ScriptedPlayActivityByName( "ACT_RUN_LEFT", true, 0.1 )
			// wait RandomFloatRange(0.04,0.5)
		// }
		// else if(random == 5|| random == 6|| random == 7|| random == 8){
		// //a d strafe
			// ai.Anim_ScriptedPlayActivityByName( "ACT_SPRINT_RIGHT", true, 0.1 )
			// wait RandomFloatRange(0.04,0.5)
			// ai.Anim_ScriptedPlayActivityByName( "ACT_SPRINT_LEFT", true, 0.1 )
			// wait RandomFloatRange(0.04,0.5)
		// }
		// else if (random == 9){
			// ai.Anim_ScriptedPlayActivityByName( "ACT_STAND", true, 0.1 )
			// wait RandomFloatRange(0.05,0.25)
		// }
		// else if(random == 10){
			

		// }
		
		// else if (random == 9){
		// //a d strafe
			// ai.Anim_ScriptedPlayActivityByName( "ACT_STRAFE_TO_CROUCH_LEFT", true, 0.1 )
			// wait RandomFloatRange(0.05,0.2)
			// ai.Anim_ScriptedPlayActivityByName( "ACT_STRAFE_TO_CROUCH_RIGHT", true, 0.1 )
			// wait RandomFloatRange(0.05,0.2)
		// }
		// else if (random == 10){
		// //circle strafe?
			// ai.Anim_ScriptedPlayActivityByName( "ACT_RUN_RIGHT", true, 0.1 )
			// wait 0.1
			// ai.Anim_ScriptedPlayActivityByName( "ACT_RUN_BACKWARD", true, 0.1 )
			// wait 0.1
			// ai.Anim_ScriptedPlayActivityByName( "ACT_RUN_LEFT", true, 0.1 )
			// wait 0.1
			// ai.Anim_ScriptedPlayActivityByName( "ACT_RUN_FORWARD", true, 0.1 )
			// wait 0.1		
		// }
	}
}

void function movementTestFunct()
{
	
	entity player = gp()[0]
	
	string anim
	float timer
	float oldtime
	while(true)
	{
		anim = player.GetCurrentSequenceName()
		WaitFrame()
		
		if(player.GetCurrentSequenceName() != anim)
			{
			printt("ai.Anim_PlayOnly(\"" + player.GetCurrentSequenceName() + "\")")
			printt("ai.SetVelocity(" + player.GetVelocity() + ")")
			printt("wait " + (Time() - oldtime))
			oldtime = Time()
			}
	}
}
// void function PlayAnimOnTrainingDummy(entity dummy)
// {
// WaitFrame()

// EndSignal(dummy, "OnDeath")

// while(IsValid(dummy))
	// {
		// float duration = dummy.GetSequenceDuration("sd_jump_explode")
		// float empezoen = RandomFloatRange(0, duration)
		// dummy.Anim_PlayOnly("sd_jump_explode")
		// dummy.Anim_SetStartTime(empezoen)
		// wait duration-empezoen
	// }
// }
// void function PlayAnimOnTrainingDummy(entity dummy)
// {
// WaitFrame()

		// foreach(string anim in ACT_ANIMS){
			// try{	
				// dummy.Anim_ScriptedPlayActivityByName( anim, true, 0.1 )
				// printt(anim)
				// }
			// catch(e420){
				// // printt(anim + " NOT WORKING FOR DUMMY")
			// }
		// }
	
// }
void function InfiniteJumpTest()
{
	entity player = gp()[0]
	player.EndSignal("OnDeath")

	while(true){
		ItemFlavor playerCharacter = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )
		asset characterSetFile = CharacterClass_GetSetFile( playerCharacter )
		player.SetPlayerSettingsWithMods( characterSetFile, ["enable_doublejump"] )

		while(true){
			if(player.IsDoubleJumping())
			{
				player.SetPlayerSettingsWithMods( characterSetFile, [] )
				player.TouchGround()
				break
			}
			WaitFrame()
		}
		WaitFrame()
	}
}

array<string> ACT_ANIMS = ["ACT_WALK",
"ACT_WALK_CASUAL",
"ACT_COVER_LOW",
"ACT_COVER_MED",
"ACT_WALK_AIM_LEFT",
"ACT_WALK_AIM_BACKWARD",
"ACT_WALK_AIM_FORWARD",
"ACT_WALK_AIM",
"ACT_WALK_STUMBLE",
"ACT_WALK_CROUCH_AIM",
"ACT_WALK_CROUCH",
"ACT_WALK_AIM_RIGHT",
"ACT_RUN_LEFT",
"ACT_RUN_BACKWARD",
"ACT_RUN_FORWARD",
"ACT_RUN",
"ACT_IDLE_COMBAT",
"ACT_IDLE",
"ACT_IDLE_CASUAL",
"ACT_RESET",
"ACT_COVER",
"ACT_TRANSITION",
"ACT_IDLE_SCAN",
"ACT_IDLE_COMBAT_AIM",
"ACT_SCRIPT_CUSTOM_MOVE",
"ACT_SPRINT_RUNAWAY",
"ACT_SPRINT_RIGHT",
"ACT_SPRINT_LEFT",
"ACT_RANGE_ATTACK1_EVASIVE",
"ACT_RANGE_ATTACK1",
"ACT_SCRIPT_CUSTOM_ATTACK2",
"ACT_SCRIPT_CUSTOM_ATTACK",
"ACT_RANGE_ATTACK2",
"ACT_RANGE_ATTACK1_LOW_SINGLE",
"ACT_RANGE_ATTACK1_LOW",
"ACT_RANGE_ATTACK1_SINGLE",
"ACT_SPECIAL_ATTACK_END",
"ACT_SPECIAL_ATTACK",
"ACT_SPECIAL_ATTACK_START",
"ACT_RANGE_ATTACK_TWITCH",
"ACT_RUN_AIM",
"ACT_RUN_DOWN",
"ACT_RUN_UP",
"ACT_RUN_RIGHT",
"ACT_RUN_AIM_RIGHT",
"ACT_RUN_AIM_LEFT",
"ACT_RUN_AIM_BACKWARD",
"ACT_RUN_AIM_FORWARD",
"ACT_RUN_CROUCH_AIM",
"ACT_RUN_CROUCH",
"ACT_RUN_AIM_DOWN",
"ACT_RUN_AIM_UP",
"ACT_SPRINT_BACKWARD",
"ACT_SPRINT_FORWARD",
"ACT_SPRINT",
"ACT_SPRINT_UNARMED",
"ACT_CROUCHIDLE_SCAN",
"ACT_CROUCHIDLE",
"ACT_CROUCH",
"ACT_WALLJUMP_RIGHT",
"ACT_SIGNAL_FORWARD",
"ACT_SIGNAL_ADVANCE",
"ACT_STAND",
"ACT_CROUCHIDLE_AIM",
"ACT_SIGNAL_RIGHT",
"ACT_SIGNAL_LEFT",
"ACT_SIGNAL_HALT",
"ACT_SIGNAL_GROUP",
"ACT_SIGNAL_SALUTE_HIGH",
"ACT_SIGNAL_SALUTE",
"ACT_SIGNAL_ACKNOWLEDGE",
"ACT_SIGNAL_TAKECOVER",
"ACT_FALL_RECOVERY",
"ACT_FALL",
"ACT_FLY",
"ACT_THROW_GRENADE",
"ACT_JUMP_LAND",
"ACT_JUMP_FLOAT",
"ACT_JUMP_START",
"ACT_JUMP",
"ACT_CLIMB_DOWN",
"ACT_CLIMB_UP",
"ACT_LAND",
"ACT_DOUBLEJUMP",
"ACT_WALLJUMP_LEFT",
"ACT_WALLRUN_RIGHT",
"ACT_WALLRUN_LEFT",
"ACT_CLIMB_DISMOUNT",
"ACT_SHOOTING_COVER_RETREAT_SIDELEAN",
"ACT_SHOOTING_COVER_ADVANCE_SIDELEAN_R",
"ACT_SHOOTING_COVER_ADVANCE_SIDELEAN_L",
"ACT_SHOOTING_COVER_ADVANCE_SIDELEAN",
"ACT_SHOOTING_COVER_ARRIVAL_SIDE_R",
"ACT_SHOOTING_COVER_ARRIVAL_SIDE_L",
"ACT_SHOOTING_COVER_RETREAT_SIDELEAN_R",
"ACT_SHOOTING_COVER_RETREAT_SIDELEAN_L",
"ACT_SHOOTING_COVER_ARRIVAL_FRONT_R",
"ACT_SHOOTING_COVER_ARRIVAL_FRONT_L",
"ACT_SHOOTING_COVER_ARRIVAL_45_R",
"ACT_SHOOTING_COVER_ARRIVAL_45_L",
"ACT_SHOOTING_COVER_GRENADE_L",
"ACT_SHOOTING_COVER_GRENADE",
"ACT_SHOOTING_COVER_ARRIVAL_FRONT_INV_R",
"ACT_SHOOTING_COVER_ARRIVAL_FRONT_INV_L",
"ACT_SIGNAL_ENRAGE",
"ACT_SIGNAL_TAUNT",
"ACT_SIGNAL_FORWARD_CROUCH",
"ACT_SIGNAL_SALUTE_CROUCH",
"ACT_SHOOTING_COVER_CHECK",
"ACT_SHOOTING_COVER_IDLE_R",
"ACT_SHOOTING_COVER_IDLE_L",
"ACT_SHOOTING_COVER_IDLE",
"ACT_SHOOTING_COVER_ADVANCE_FORWARD_L",
"ACT_SHOOTING_COVER_ADVANCE_FORWARD",
"ACT_SHOOTING_COVER_CHECK_R",
"ACT_SHOOTING_COVER_CHECK_L",
"ACT_SHOOTING_COVER_RETREAT_BACKWARD_R",
"ACT_SHOOTING_COVER_RETREAT_BACKWARD_L",
"ACT_SHOOTING_COVER_RETREAT_BACKWARD",
"ACT_SHOOTING_COVER_ADVANCE_FORWARD_R",
"ACT_MELEE_BACK",
"ACT_MELEE_RIGHT",
"ACT_MELEE_LEFT",
"ACT_MELEE_RAM",
"ACT_SWITCH_WEAPON",
"ACT_RELOAD_LOW",
"ACT_RELOAD",
"ACT_MELEE_JUMP_UP",
"ACT_DIESIMPLE",
"ACT_VICTORY_DANCE",
"ACT_DISARM",
"ACT_ARM",
"ACT_DIE_RIGHT",
"ACT_DIE_LEFT",
"ACT_DIEFORWARD",
"ACT_DIEBACKWARD",
"ACT_SHOOTING_COVER_GRENADE_ADVANCE_R",
"ACT_SHOOTING_COVER_GRENADE_ADVANCE_L",
"ACT_SHOOTING_COVER_GRENADE_ADVANCE",
"ACT_SHOOTING_COVER_GRENADE_R",
"ACT_MELEE_ATTACK1",
"ACT_BRACE",
"ACT_COWER",
"ACT_DISENGAGE",
"ACT_MELEE_CHARGE_HIT",
"ACT_MELEE_CHARGE",
"ACT_MELEE_HIGH",
"ACT_MELEE_ATTACK_WAIT",
"ACT_MELEE_CHARGE_HIGH_MISS",
"ACT_MELEE_CHARGE_HIGH_HIT",
"ACT_MELEE_CHARGE_HIGH",
"ACT_MELEE_CHARGE_MISS",
"ACT_BIG_FLINCH",
"ACT_SMALL_FLINCH",
"ACT_DIE_DOWNED_KILL",
"ACT_DIE_BLEEDOUT",
"ACT_FLINCH_STOMACH",
"ACT_FLINCH_CHEST",
"ACT_FLINCH_HEAD",
"ACT_STUNNED",
"ACT_FLINCH_RIGHTLEG",
"ACT_FLINCH_LEFTLEG",
"ACT_FLINCH_RIGHTARM",
"ACT_FLINCH_LEFTARM",
"ACT_FLINCH_CROUCH_RIGHT",
"ACT_FLINCH_CROUCH_LEFT",
"ACT_FLINCH_CROUCH_BACK",
"ACT_FLINCH_CROUCH_FRONT",
"ACT_DIE_GUTSHOT",
"ACT_DIE_CHESTSHOT",
"ACT_DIE_HEADSHOT",
"ACT_DIERAGDOLL",
"ACT_DIE_RUNNING",
"ACT_DIE_BACK_CROUCH",
"ACT_DIE_FRONT_CROUCH",
"ACT_DIE_BACKSHOT",
"ACT_DIE_KNOCKBACK_FORWARD",
"ACT_DIE_INSTANT_CROUCH",
"ACT_DIE_INSTANT_RUNNING",
"ACT_DIE_INSTANT_STANDING",
"ACT_DIE_GRAPPLE",
"ACT_DIE_KNOCKBACK_BACK",
"ACT_DIE_KNOCKBACK_RIGHT",
"ACT_DIE_KNOCKBACK_LEFT",
"ACT_180_RIGHT_CROUCH",
"ACT_180_LEFT_CROUCH",
"ACT_90_RIGHT_CROUCH",
"ACT_90_LEFT_CROUCH",
"ACT_90_RIGHT_NONCOMBAT",
"ACT_90_LEFT_NONCOMBAT",
"ACT_45_RIGHT_NONCOMBAT",
"ACT_45_LEFT_NONCOMBAT",
"ACT_GESTURE_GUN_UP",
"ACT_GESTURE_RANGE_ATTACK1",
"ACT_180_RIGHT_NONCOMBAT",
"ACT_180_LEFT_NONCOMBAT",
"ACT_GESTURE_MELEE_ATTACK2",
"ACT_GESTURE_MELEE_ATTACK1",
"ACT_GESTURE_BLOCK",
"ACT_GESTURE_THREAT_DISPLAY",
"ACT_FLINCH_GRAPPLE",
"ACT_FLINCH_RAM_CRASH",
"ACT_FLINCH_RUNNING_BUMP",
"ACT_FLINCH_RUNNING",
"ACT_FLINCH_KNOCKBACK_BACK",
"ACT_FLINCH_KNOCKBACK_RIGHT",
"ACT_FLINCH_KNOCKBACK_LEFT",
"ACT_FLINCH_KNOCKBACK_FORWARD",
"ACT_90_RIGHT",
"ACT_90_LEFT",
"ACT_45_RIGHT",
"ACT_45_LEFT",
"ACT_45_RIGHT_CROUCH",
"ACT_45_LEFT_CROUCH",
"ACT_180_RIGHT",
"ACT_180_LEFT",
"ACT_GESTURE_TURN_RIGHT90",
"ACT_GESTURE_TURN_LEFT90",
"ACT_GESTURE_TURN_RIGHT45",
"ACT_GESTURE_TURN_LEFT45",
"ACT_GESTURE_TURN_RIGHT90_FLAT",
"ACT_GESTURE_TURN_LEFT90_FLAT",
"ACT_GESTURE_TURN_RIGHT45_FLAT",
"ACT_GESTURE_TURN_LEFT45_FLAT",
"ACT_DODGE_BACKWARD",
"ACT_DODGE_FORWARD",
"ACT_GESTURE_RELOAD",
"ACT_RANGE_ATTACK_SMG1",
"ACT_DODGE_RIGHT_FAR",
"ACT_DODGE_LEFT_FAR",
"ACT_DODGE_RIGHT",
"ACT_DODGE_LEFT",
"ACT_GESTURE_FLINCH_BLAST",
"ACT_GESTURE_BIG_FLINCH",
"ACT_GESTURE_SMALL_FLINCH",
"ACT_GESTURE_MELEE_ATTACK3",
"ACT_GESTURE_FLINCH_HEAD",
"ACT_GESTURE_FLINCH_BLAST_DAMAGED_SHOTGUN",
"ACT_GESTURE_FLINCH_BLAST_DAMAGED",
"ACT_GESTURE_FLINCH_BLAST_SHOTGUN",
"ACT_GESTURE_FLINCH_RIGHTARM",
"ACT_GESTURE_FLINCH_LEFTARM",
"ACT_GESTURE_FLINCH_STOMACH",
"ACT_GESTURE_FLINCH_CHEST",
"ACT_GESTURE_TURN_RIGHT",
"ACT_GESTURE_TURN_LEFT",
"ACT_GESTURE_FLINCH_RIGHTLEG",
"ACT_GESTURE_FLINCH_LEFTLEG",
"ACT_REACT_CLOAK_DISAPPEAR_NEAR",
"ACT_REACT_CLOAK_APPEAR_FAR",
"ACT_REACT_CLOAK_APPEAR_NEAR",
"ACT_REACT_BULLET_FAR",
"ACT_SEARCH_CORPSE",
"ACT_SEARCH_LOOK_AROUND",
"ACT_SEARCH_AREA_CLEAR",
"ACT_REACT_CLOAK_DISAPPEAR_FAR",
"ACT_RUN_CHECK_RIGHT",
"ACT_RUN_CHECK_LEFT",
"ACT_SEARCH_LEAD_WALK",
"ACT_SEARCH_WALK",
"ACT_PIE_OFF_RIGHT",
"ACT_PIE_OFF_LEFT",
"ACT_RUN_PEEK_CORNER_RIGHT",
"ACT_RUN_PEEK_CORNER_LEFT",
"ACT_DODGE_RIGHT_WALLHOP",
"ACT_DODGE_LEFT_WALLHOP",
"ACT_DODGE_RIGHT_RUN",
"ACT_DODGE_LEFT_RUN",
"ACT_DEPLOY",
"ACT_WALK_CARRY",
"ACT_IDLE_CARRY",
"ACT_OPEN_DOOR",
"ACT_REACT_SURPRISED",
"ACT_REACT_JUMPED_OVER",
"ACT_UNDEPLOY",
"ACT_DEPLOY_IDLE",
"ACT_REACT_BULLET",
"ACT_REACT_SURPRISED_BACK",
"ACT_REACT_SURPRISED_RIGHT",
"ACT_REACT_SURPRISED_LEFT",
"ACT_STAND_TO_WALK_FORWARD",
"ACT_STAND_TO_WALK_45_RIGHT",
"ACT_STAND_TO_WALK_90_RIGHT",
"ACT_STAND_TO_WALK_135_RIGHT",
"ACT_STAND_TO_WALK_180_LEFT",
"ACT_STAND_TO_WALK_135_LEFT",
"ACT_STAND_TO_WALK_90_LEFT",
"ACT_STAND_TO_WALK_45_LEFT",
"ACT_STAND_TO_WALK_CASUAL_45_RIGHT",
"ACT_STAND_TO_WALK_CASUAL_90_RIGHT",
"ACT_STAND_TO_WALK_CASUAL_135_RIGHT",
"ACT_STAND_TO_WALK_CASUAL_180_RIGHT",
"ACT_STAND_TO_WALK_CASUAL_135_LEFT",
"ACT_STAND_TO_WALK_CASUAL_90_LEFT",
"ACT_STAND_TO_WALK_CASUAL_45_LEFT",
"ACT_STAND_TO_WALK_CASUAL_FORWARD",
"ACT_RELOAD_DODGE_RIGHT",
"ACT_RELOAD_DODGE_LEFT",
"ACT_PIE_OFF_AND_BACK_RIGHT",
"ACT_PIE_OFF_AND_BACK_LEFT",
"ACT_STAND_TO_RUN_135_RIGHT",
"ACT_STAND_TO_RUN_180_RIGHT",
"ACT_STAND_TO_STAGGER",
"ACT_STAND_TO_CRAWL",
"ACT_STAND_TO_RUN_45_LEFT",
"ACT_STAND_TO_RUN_FORWARD",
"ACT_STAND_TO_RUN_45_RIGHT",
"ACT_STAND_TO_RUN_90_RIGHT",
"ACT_STAND_TO_WALK_180_RIGHT",
"ACT_STAND_TO_RUN_180_LEFT",
"ACT_STAND_TO_RUN_135_LEFT",
"ACT_STAND_TO_RUN_90_LEFT",
"ACT_RUN_TO_STAND_45_RIGHT",
"ACT_RUN_TO_STAND_90_RIGHT",
"ACT_RUN_TO_STAND_135_RIGHT",
"ACT_RUN_TO_STAND_180_RIGHT",
"ACT_RUN_TO_STAND_135_LEFT",
"ACT_RUN_TO_STAND_90_LEFT",
"ACT_RUN_TO_STAND_45_LEFT",
"ACT_RUN_TO_STAND_FORWARD",
"ACT_WALK_TO_STAND_90_RIGHT",
"ACT_WALK_TO_STAND_135_RIGHT",
"ACT_WALK_TO_STAND_180_RIGHT",
"ACT_RUN_TO_STAND_180_LEFT",
"ACT_WALK_TO_STAND_90_LEFT",
"ACT_WALK_TO_STAND_45_LEFT",
"ACT_WALK_TO_STAND_FORWARD",
"ACT_WALK_TO_STAND_45_RIGHT",
"ACT_STAND_TO_BACKPEDAL",
"ACT_STAND_TO_STRAFE_LEFT",
"ACT_STAND_TO_WALK_CASUAL_180_LEFT",
"ACT_CROUCH_TO_RUN_180_RIGHT",
"ACT_CROUCH_TO_BACKPEDAL",
"ACT_CROUCH_TO_STRAFE_LEFT",
"ACT_CROUCH_TO_STRAFE_RIGHT",
"ACT_CROUCH_TO_RUN_FORWARD",
"ACT_CROUCH_TO_RUN_45_RIGHT",
"ACT_CROUCH_TO_RUN_90_RIGHT",
"ACT_CROUCH_TO_RUN_135_RIGHT",
"ACT_CROUCH_TO_RUN_180_LEFT",
"ACT_CROUCH_TO_RUN_135_LEFT",
"ACT_CROUCH_TO_RUN_90_LEFT",
"ACT_CROUCH_TO_RUN_45_LEFT",
"ACT_RUN_TO_CROUCH_180_RIGHT",
"ACT_EXIT_BACKPEDAL_TO_FORWARD_180",
"ACT_STAND_TO_RUN_BLINDFIRE_180",
"ACT_STRAFE_TO_CROUCH_BACKPEDAL",
"ACT_RUN_TO_CROUCH_FORWARD",
"ACT_RUN_TO_CROUCH_45_RIGHT",
"ACT_RUN_TO_CROUCH_90_RIGHT",
"ACT_RUN_TO_CROUCH_135_RIGHT",
"ACT_RUN_TO_CROUCH_180_LEFT",
"ACT_RUN_TO_CROUCH_135_LEFT",
"ACT_RUN_TO_CROUCH_90_LEFT",
"ACT_RUN_TO_CROUCH_45_LEFT",
"ACT_STAND_TO_FLEE_45_RIGHT",
"ACT_STAND_TO_FLEE_90_RIGHT",
"ACT_STAND_TO_FLEE_135_RIGHT",
"ACT_STAND_TO_FLEE_180_RIGHT",
"ACT_WALK_CASUAL_TO_STAND_135_RIGHT",
"ACT_WALK_CASUAL_TO_STAND_180_RIGHT",
"ACT_WALK_TO_STAND_180_LEFT",
"ACT_WALK_TO_STAND_135_LEFT",
"ACT_WALK_CASUAL_TO_STAND_45_LEFT",
"ACT_WALK_CASUAL_TO_STAND_FORWARD",
"ACT_WALK_CASUAL_TO_STAND_45_RIGHT",
"ACT_WALK_CASUAL_TO_STAND_90_RIGHT",
"ACT_STRAFE_TO_STAND_RIGHT",
"ACT_WALK_CASUAL_TO_STAND_180_LEFT",
"ACT_WALK_CASUAL_TO_STAND_135_LEFT",
"ACT_WALK_CASUAL_TO_STAND_90_LEFT",
"ACT_STRAFE_TO_CROUCH_LEFT",
"ACT_STRAFE_TO_CROUCH_RIGHT",
"ACT_STRAFE_TO_STAND_BACKPEDAL",
"ACT_STRAFE_TO_STAND_LEFT",
"ACT_WALK_TURN_45_LEFT",
"ACT_WALK_TURN_FORWARD",
"ACT_WALK_TURN_45_RIGHT",
"ACT_WALK_TURN_90_RIGHT",
"ACT_WALK_CASUAL_TURN_180_RIGHT",
"ACT_WALK_TURN_180_LEFT",
"ACT_WALK_TURN_135_LEFT",
"ACT_WALK_TURN_90_LEFT",
"ACT_WALK_CASUAL_TURN_FORWARD",
"ACT_WALK_CASUAL_TURN_45_RIGHT",
"ACT_WALK_CASUAL_TURN_90_RIGHT",
"ACT_WALK_CASUAL_TURN_135_RIGHT",
"ACT_WALK_CASUAL_TURN_180_LEFT",
"ACT_WALK_CASUAL_TURN_135_LEFT",
"ACT_WALK_CASUAL_TURN_90_LEFT",
"ACT_WALK_CASUAL_TURN_45_LEFT",
"ACT_STAND_TO_FLEE_135_LEFT",
"ACT_STAND_TO_FLEE_90_LEFT",
"ACT_STAND_TO_FLEE_45_LEFT",
"ACT_STAND_TO_FLEE_FORWARD",
"ACT_RUN_TURN_90_RIGHT",
"ACT_RUN_TURN_135_RIGHT",
"ACT_RUN_TURN_180_RIGHT",
"ACT_STAND_TO_FLEE_180_LEFT",
"ACT_RUN_TURN_90_LEFT",
"ACT_RUN_TURN_45_LEFT",
"ACT_RUN_TURN_FORWARD",
"ACT_RUN_TURN_45_RIGHT",
"ACT_WALK_TURN_135_RIGHT",
"ACT_WALK_TURN_180_RIGHT",
"ACT_RUN_TURN_180_LEFT",
"ACT_RUN_TURN_135_LEFT",
"ACT_TRAVERSE_ACROSS_256_DOWN_128",
"ACT_TRAVERSE_ACROSS_256_REVERSE",
"ACT_TRAVERSE_ACROSS_256",
"ACT_TRAVERSE_ACROSS_128_REVERSE",
"ACT_TRAVERSE_ACROSS_512_DOWN_128",
"ACT_TRAVERSE_ACROSS_512_REVERSE",
"ACT_TRAVERSE_ACROSS_512",
"ACT_TRAVERSE_ACROSS_256_UP_128",
"ACT_TRAVERSE_ACROSS_1024_DOWN_256",
"ACT_TRAVERSE_ACROSS_1024_REVERSE",
"ACT_TRAVERSE_ACROSS_1024",
"ACT_TRAVERSE_ACROSS_512_UP_128",
"ACT_TRAVERSE_DOWN_WINDOW_256",
"ACT_TRAVERSE_UP_WINDOW_192",
"ACT_TRAVERSE_DOWN_WINDOW_192",
"ACT_TRAVERSE_ACROSS_1024_UP_256",
"ACT_TRAVERSE_DOWN_128",
"ACT_TRAVERSE_DOWN_64",
"ACT_TRAVERSE_DOWN_40",
"ACT_KNOCK_AWAY_PHYS_ENTS",
"ACT_TRAVERSE_UP_64",
"ACT_TRAVERSE_UP_40",
"ACT_TRAVERSE_DOWN_640",
"ACT_TRAVERSE_DOWN_256",
"ACT_TRAVERSE_UP_640",
"ACT_TRAVERSE_UP_256_CLIMB",
"ACT_TRAVERSE_UP_256",
"ACT_TRAVERSE_UP_128",
"ACT_TRAVERSE_ACROSS_128",
"ACT_TRAVERSE_DOOR",
"ACT_TRAVERSE_OVER",
"ACT_TRAVERSE_UP_640_CLIMB",
"ACT_VM_DISCARD",
"ACT_VM_LOWER",
"ACT_VM_RAISE_FROM_MELEE",
"ACT_VM_RAISE_FROM_SPRINT",
"ACT_VM_ADS_IN_ALT3",
"ACT_VM_ADS_IN_ALT2",
"ACT_VM_ADS_IN_ALT1",
"ACT_VM_ADS_IN",
"ACT_VM_ADS_OUT_ALT3",
"ACT_VM_ADS_OUT_ALT2",
"ACT_VM_ADS_OUT_ALT1",
"ACT_VM_ADS_OUT",
"ACT_VM_IDLE_ALT3",
"ACT_VM_IDLE_ALT2",
"ACT_VM_IDLE_ALT1",
"ACT_VM_IDLE",
"ACT_RODEOED_STAND_IDLE",
"ACT_SPECIFIC_SEQUENCE",
"ACT_DO_NOT_DISTURB",
"ACT_TRAVERSE_UP_WINDOW_256",
"ACT_ZIPLINE_MOUNT",
"ACT_RODEOED_CROUCHWALK",
"ACT_RODEOED_WALK",
"ACT_RODEOED_CROUCH_IDLE",
"ACT_VM_DRAWFIRST",
"ACT_VM_DRAW_TO_SPRINT",
"ACT_VM_DRAW",
"ACT_ZIPLINING",
"ACT_VM_RAISE",
"ACT_VM_HOLSTER_FROM_SPRINT",
"ACT_VM_HOLSTER",
"ACT_VM_DRAWCATCH",
"ACT_VM_PRIMARYATTACK_ALT3_SEQUENTIAL",
"ACT_VM_PRIMARYATTACK_ALT2_SEQUENTIAL",
"ACT_VM_PRIMARYATTACK_ALT1_SEQUENTIAL",
"ACT_VM_PRIMARYATTACK_SEQUENTIAL",
"ACT_VM_MELEE_ATTACK3",
"ACT_VM_MELEE_ATTACK2",
"ACT_VM_MELEE_ATTACK1",
"ACT_VM_SECONDARYATTACK",
"ACT_VM_RELOAD",
"ACT_VM_MELEE_CHARGE",
"ACT_VM_MELEE_KNIFE",
"ACT_VM_MELEE_KNIFE_FIRST",
"ACT_VM_RELOAD_LATE4",
"ACT_VM_RELOAD_LATE3",
"ACT_VM_RELOAD_LATE2",
"ACT_VM_RELOAD_LATE1",
"ACT_VM_CHARGE_VER3",
"ACT_VM_CHARGE_VER2",
"ACT_VM_CHARGE_VER1",
"ACT_VM_CHARGE",
"ACT_VM_FIDGET",
"ACT_VM_SPRINT",
"ACT_VM_CHARGE_LEVEL_INCREASE",
"ACT_VM_CHARGE_VER4",
"ACT_VM_THROW",
"ACT_VM_PULLBACK_LOW",
"ACT_VM_PULLBACK_HIGH",
"ACT_VM_PULLBACK",
"ACT_VM_PRIMARYATTACK_ALT3",
"ACT_VM_PRIMARYATTACK_ALT2",
"ACT_VM_PRIMARYATTACK_ALT1",
"ACT_VM_PRIMARYATTACK",
"ACT_VM_SEGMENTEDRELOAD_LOOP",
"ACT_VM_RELOADEMPTY_LATE5_ALT1",
"ACT_VM_RELOADEMPTY_LATE4_ALT1",
"ACT_VM_RELOADEMPTY_LATE3_ALT1",
"ACT_VM_HITCENTER",
"ACT_VM_DRYFIRE",
"ACT_VM_SEGMENTEDEMPTYRELOAD_END",
"ACT_VM_SEGMENTEDRELOAD_END",
"ACT_VM_HAULBACK",
"ACT_VM_MISSCENTER2",
"ACT_VM_MISSCENTER",
"ACT_VM_HITCENTER2",
"ACT_VM_PICKUP",
"ACT_VM_RECOIL3",
"ACT_VM_RECOIL2",
"ACT_VM_RECOIL1",
"ACT_VM_RELOADEMPTY_LATE2",
"ACT_VM_RELOADEMPTY_LATE1",
"ACT_VM_RELOADEMPTY",
"ACT_VM_RELOAD_LATE5",
"ACT_VM_RELOAD_ALT1",
"ACT_VM_RELOADEMPTY_LATE5",
"ACT_VM_RELOADEMPTY_LATE4",
"ACT_VM_RELOADEMPTY_LATE3",
"ACT_VM_RELOAD_LATE4_ALT1",
"ACT_VM_RELOAD_LATE3_ALT1",
"ACT_VM_RELOAD_LATE2_ALT1",
"ACT_VM_RELOAD_LATE1_ALT1",
"ACT_VM_RELOADEMPTY_LATE2_ALT1",
"ACT_VM_RELOADEMPTY_LATE1_ALT1",
"ACT_VM_RELOADEMPTY_ALT1",
"ACT_VM_RELOAD_LATE5_ALT1",
"ACT_VM_GRAPPLE_IDLE",
"ACT_VM_GRAPPLE_START",
"ACT_VM_DASH",
"ACT_VM_COOLDOWN_OVERHEAT_LATE3",
"ACT_VM_DOUBLEJUMP",
"ACT_VM_JUMP",
"ACT_VM_WEAPON_INSPECT",
"ACT_VM_GRAPPLE_STOP",
"ACT_VM_LAND_HIGH",
"ACT_VM_LAND_MEDIUM",
"ACT_VM_LAND_LOW",
"ACT_VM_LAND",
"ACT_VM_TRAVERSAL_WINDOW_LEFT",
"ACT_VM_SUSTAINED_DISCHARGE",
"ACT_VM_WEAPON_MOD_REMOVE",
"ACT_VM_WEAPON_MOD_ADD",
"ACT_VM_RECHAMBER_LATE2",
"ACT_VM_RECHAMBER_LATE1",
"ACT_VM_RECHAMBER",
"ACT_VM_RELEASE",
"ACT_VM_TOSS_OVERHEAD",
"ACT_VM_TOSS",
"ACT_VM_ZIPLINE_MOUNT",
"ACT_VM_RECHAMBER_LATE3",
"ACT_VM_TOSS_HOLD_SPRINTING",
"ACT_VM_TOSS_HOLD",
"ACT_VM_TOSS_PREP_PULLOUT",
"ACT_VM_TOSS_PREP",
"ACT_VM_COOLDOWN_OVERHEAT_LATE2",
"ACT_VM_COOLDOWN_OVERHEAT_LATE1",
"ACT_VM_COOLDOWN_OVERHEAT",
"ACT_VM_COOLDOWN",
"ACT_VM_ONEHANDED_IDLE",
"ACT_VM_ONEHANDED_ADS_OUT_ALT3",
"ACT_VM_ONEHANDED_ADS_OUT_ALT2",
"ACT_VM_ONEHANDED_ADS_OUT_ALT1",
"ACT_VM_ONEHANDED_CHARGE",
"ACT_VM_ONEHANDED_IDLE_ALT3",
"ACT_VM_ONEHANDED_IDLE_ALT2",
"ACT_VM_ONEHANDED_IDLE_ALT1",
"ACT_VM_ONEHANDED_PRIMARYATTACK_ALT2",
"ACT_VM_ONEHANDED_PRIMARYATTACK_ALT1",
"ACT_VM_ONEHANDED_PRIMARYATTACK",
"ACT_VM_ONEHANDED_SPRINT",
"ACT_VM_ONEHANDED_PRIMARYATTACK_ALT2_SEQUENTIAL",
"ACT_VM_ONEHANDED_PRIMARYATTACK_ALT1_SEQUENTIAL",
"ACT_VM_ONEHANDED_PRIMARYATTACK_SEQUENTIAL",
"ACT_VM_ONEHANDED_PRIMARYATTACK_ALT3",
"ACT_VM_MANTLE_ABOVE",
"ACT_VM_MANTLE_LEVEL",
"ACT_VM_MANTLE_BELOW",
"ACT_VM_TRAVERSAL_WINDOW_RIGHT",
"ACT_VM_MANTLE_CROUCH_ABOVE",
"ACT_VM_MANTLE_CROUCH_LEVEL",
"ACT_VM_MANTLE_CROUCH_BELOW",
"ACT_VM_MANTLE_HIGH",
"ACT_VM_ONEHANDED_ADS_IN",
"ACT_VM_MANTLE_JUMPOFF",
"ACT_VM_MANTLE_IDLE",
"ACT_VM_MANTLE_CROUCH_HIGH",
"ACT_VM_ONEHANDED_ADS_OUT",
"ACT_VM_ONEHANDED_ADS_IN_ALT3",
"ACT_VM_ONEHANDED_ADS_IN_ALT2",
"ACT_VM_ONEHANDED_ADS_IN_ALT1",
"ACT_VM_ONEHANDED_RELOADEMPTY_ALT1",
"ACT_VM_ONEHANDED_RELOAD_LATE5_ALT1",
"ACT_VM_ONEHANDED_RELOAD_LATE4_ALT1",
"ACT_VM_ONEHANDED_RELOAD_LATE3_ALT1",
"ACT_VM_ONEHANDED_RELOADEMPTY_LATE4_ALT1",
"ACT_VM_ONEHANDED_RELOADEMPTY_LATE3_ALT1",
"ACT_VM_ONEHANDED_RELOADEMPTY_LATE2_ALT1",
"ACT_VM_ONEHANDED_RELOADEMPTY_LATE1_ALT1",
"ACT_VM_ONEHANDED_SEGMENTEDEMPTYRELOAD_END",
"ACT_VM_ONEHANDED_SEGMENTEDRELOAD_END",
"ACT_VM_ONEHANDED_SEGMENTEDRELOAD_LOOP",
"ACT_VM_ONEHANDED_RELOADEMPTY_LATE5_ALT1",
"ACT_VM_ONEHANDED_RECHAMBER_LATE3",
"ACT_VM_ONEHANDED_RECHAMBER_LATE2",
"ACT_VM_ONEHANDED_RECHAMBER_LATE1",
"ACT_VM_ONEHANDED_RECHAMBER",
"ACT_VM_ONEHANDED_RELOAD_LATE2",
"ACT_VM_ONEHANDED_RELOAD_LATE1",
"ACT_VM_ONEHANDED_RELOAD",
"ACT_VM_ONEHANDED_PRIMARYATTACK_ALT3_SEQUENTIAL",
"ACT_VM_ONEHANDED_RELOADEMPTY",
"ACT_VM_ONEHANDED_RELOAD_LATE5",
"ACT_VM_ONEHANDED_RELOAD_LATE4",
"ACT_VM_ONEHANDED_RELOAD_LATE3",
"ACT_VM_ONEHANDED_RELOADEMPTY_LATE4",
"ACT_VM_ONEHANDED_RELOADEMPTY_LATE3",
"ACT_VM_ONEHANDED_RELOADEMPTY_LATE2",
"ACT_VM_ONEHANDED_RELOADEMPTY_LATE1",
"ACT_VM_ONEHANDED_RELOAD_LATE2_ALT1",
"ACT_VM_ONEHANDED_RELOAD_LATE1_ALT1",
"ACT_VM_ONEHANDED_RELOAD_ALT1",
"ACT_VM_ONEHANDED_RELOADEMPTY_LATE5",
"ACT_MP_CROUCH_DEPLOYED_IDLE",
"ACT_MP_CROUCH_IDLE",
"ACT_MP_STAND_IDLE",
"ACT_VM_ONEHANDED_SUSTAINED_DISCHARGE",
"ACT_MP_RUN_FORWARD",
"ACT_MP_RUN",
"ACT_MP_DEPLOYED_IDLE",
"ACT_MP_CROUCH_DEPLOYED",
"ACT_MP_STAGGERED_RUN",
"ACT_MP_RUN_RIGHT",
"ACT_MP_RUN_LEFT",
"ACT_MP_RUN_BACKWARD",
"ACT_MP_STAGGERED_RUN_RIGHT",
"ACT_MP_STAGGERED_RUN_LEFT",
"ACT_MP_STAGGERED_RUN_BACKWARD",
"ACT_MP_STAGGERED_RUN_FORWARD",
"ACT_VM_ONEHANDED_LOWER",
"ACT_VM_ONEHANDED_HOLSTER",
"ACT_VM_ONEHANDED_DRAWFIRST",
"ACT_VM_ONEHANDED_DRAW",
"ACT_VM_ONEHANDED_TOSS",
"ACT_VM_ONEHANDED_RAISE_FROM_MELEE",
"ACT_VM_ONEHANDED_RAISE_FROM_SPRINT",
"ACT_VM_ONEHANDED_RAISE",
"ACT_VM_ONEHANDED_TOSS_HOLD",
"ACT_VM_ONEHANDED_TOSS_PREP_PULLOUT",
"ACT_VM_ONEHANDED_TOSS_PREP",
"ACT_VM_ONEHANDED_TOSS_OVERHEAD",
"ACT_VM_ONEHANDED_COOLDOWN_OVERHEAT_LATE3",
"ACT_VM_ONEHANDED_COOLDOWN_OVERHEAT_LATE2",
"ACT_VM_ONEHANDED_COOLDOWN_OVERHEAT_LATE1",
"ACT_VM_ONEHANDED_COOLDOWN_OVERHEAT",
"ACT_MP_STAGGERED_CROUCHWALK_LEFT",
"ACT_MP_STAGGERED_CROUCHWALK_BACKWARD",
"ACT_MP_STAGGERED_CROUCHWALK_FORWARD",
"ACT_MP_STAGGERED_CROUCHWALK",
"ACT_MP_SLIDE",
"ACT_MP_STAGGERED_SPRINT",
"ACT_MP_SPRINT",
"ACT_MP_STAGGERED_CROUCHWALK_RIGHT",
"ACT_MP_SLIDE_RIGHT",
"ACT_MP_SLIDE_LEFT",
"ACT_MP_SLIDE_BACKWARD",
"ACT_MP_SLIDE_FORWARD",
"ACT_MP_JUMP_LAND",
"ACT_MP_JUMP_FLOAT",
"ACT_MP_JUMP_START",
"ACT_MP_JUMP",
"ACT_MP_WALK_LEFT",
"ACT_MP_WALK_BACKWARD",
"ACT_MP_WALK_FORWARD",
"ACT_MP_WALK",
"ACT_MP_STAGGERED_WALK_BACKWARD",
"ACT_MP_STAGGERED_WALK_FORWARD",
"ACT_MP_STAGGERED_WALK",
"ACT_MP_WALK_RIGHT",
"ACT_MP_CROUCHWALK",
"ACT_MP_AIRWALK",
"ACT_MP_STAGGERED_WALK_RIGHT",
"ACT_MP_STAGGERED_WALK_LEFT",
"ACT_MP_CROUCHWALK_RIGHT",
"ACT_MP_CROUCHWALK_LEFT",
"ACT_MP_CROUCHWALK_BACKWARD",
"ACT_MP_CROUCHWALK_FORWARD",
"ACT_MP_JUMP_IMPACT_N",
"ACT_MP_JUMP_LAND_HIGH_RIGHT",
"ACT_MP_JUMP_LAND_HIGH_LEFT",
"ACT_MP_JUMP_LAND_HIGH_BACKWARD",
"ACT_MP_JUMP_IMPACT_TOP",
"ACT_MP_JUMP_IMPACT_S",
"ACT_MP_JUMP_IMPACT_W",
"ACT_MP_JUMP_IMPACT_E",
"ACT_MP_DODGE",
"ACT_MP_VCD",
"ACT_MP_DEPLOYED",
"ACT_MP_DOUBLEJUMP",
"ACT_MP_DODGE_RIGHT",
"ACT_MP_DODGE_LEFT",
"ACT_MP_DODGE_BACKWARD",
"ACT_MP_DODGE_FORWARD",
"ACT_MP_JUMP_LAND_RIGHT",
"ACT_MP_JUMP_LAND_LEFT",
"ACT_MP_JUMP_LAND_BACKWARD",
"ACT_MP_JUMP_LAND_FORWARD",
"ACT_MP_JUMP_LAND_LOW_LEFT",
"ACT_MP_JUMP_LAND_LOW_BACKWARD",
"ACT_MP_JUMP_LAND_LOW_FORWARD",
"ACT_MP_JUMP_LAND_LOW",
"ACT_MP_JUMP_LAND_MEDIUM_BACKWARD",
"ACT_MP_JUMP_LAND_MEDIUM_FORWARD",
"ACT_MP_JUMP_LAND_MEDIUM",
"ACT_MP_JUMP_LAND_LOW_RIGHT",
"ACT_MP_JUMP_LAND_HIGH_FORWARD",
"ACT_MP_JUMP_LAND_HIGH",
"ACT_MP_JUMP_LAND_MEDIUM_RIGHT",
"ACT_MP_JUMP_LAND_MEDIUM_LEFT",
"ACT_MP_WALLHANG_RIGHT",
"ACT_MP_WALLHANG_LEFT",
"ACT_MP_WALLHANG_IDLE",
"ACT_MP_WALLRUN_FALL_RIGHT",
"ACT_MP_WALLJUMP_RIGHT",
"ACT_MP_WALLJUMP_LEFT",
"ACT_MP_WALLHANG_FRONT",
"ACT_MP_WALLHANG_UP",
"ACT_MP_CROUCHSLIDE_END_BACKWARD_LEFT",
"ACT_MP_CROUCHSLIDE_END_FORWARD",
"ACT_MP_CROUCHSLIDE",
"ACT_MP_WALLJUMP_UP",
"ACT_MP_CROUCHSLIDE_AIR",
"ACT_MP_CROUCHSLIDE_END_RIGHT",
"ACT_MP_CROUCHSLIDE_END_LEFT",
"ACT_MP_CROUCHSLIDE_END_BACKWARD_RIGHT",
"ACT_MP_DODGE_FLOAT_LEFT",
"ACT_MP_DODGE_FLOAT_BACKWARD",
"ACT_MP_DODGE_FLOAT_FORWARD",
"ACT_MP_DODGE_FLOAT",
"ACT_MP_DODGE_LAND_BACKWARD",
"ACT_MP_DODGE_LAND_FORWARD",
"ACT_MP_DODGE_LAND",
"ACT_MP_DODGE_FLOAT_RIGHT",
"ACT_MP_WALLRUN_LEFT",
"ACT_MP_WALLRUN_UP",
"ACT_MP_DODGE_LAND_RIGHT",
"ACT_MP_DODGE_LAND_LEFT",
"ACT_MP_WALLRUN_FALL_LEFT",
"ACT_MP_WALLRUN_FALL_FRONT",
"ACT_MP_WALLRUN_FALL_BACK",
"ACT_MP_WALLRUN_RIGHT",
"ACT_MP_ATTACK_STAND_PRIMARYFIRE",
"ACT_MP_MANTLE_JUMPOFF",
"ACT_MP_MANTLE_IDLE",
"ACT_MP_MANTLE_CROUCH_HIGH",
"ACT_MP_ATTACK_CROUCH_PRIMARYFIRE",
"ACT_MP_ATTACK_STAND_GRENADE_PULLOUT",
"ACT_MP_ATTACK_STAND_GRENADE",
"ACT_MP_ATTACK_STAND_SECONDARYFIRE",
"ACT_MP_ATTACK_AIRWALK_SECONDARYFIRE",
"ACT_MP_ATTACK_AIRWALK_PRIMARYFIRE",
"ACT_MP_ATTACK_CROUCH_GRENADE",
"ACT_MP_ATTACK_CROUCH_SECONDARYFIRE",
"ACT_MP_OFFHAND_START",
"ACT_MP_RELOAD_CROUCH",
"ACT_MP_RELOAD_STAND",
"ACT_MP_ATTACK_AIRWALK_GRENADE",
"ACT_MP_FREEFALL_ANTICIPATE",
"ACT_MP_FREEFALL",
"ACT_MP_GESTURE_GRAPPLE_FIRE",
"ACT_MP_GRAPPLE",
"ACT_MP_TRAVERSAL_WINDOW_LEFT",
"ACT_MP_VEHICLE_DRIVER_IDLE",
"ACT_MP_FREEFALL_TRANSITION_FROM_ANTICIPATE",
"ACT_MP_FREEFALL_TRANSITION_TO_ANTICIPATE",
"ACT_MP_MANTLE_ABOVE",
"ACT_MP_MANTLE_LEVEL",
"ACT_MP_MANTLE_BELOW",
"ACT_MP_TRAVERSAL_WINDOW_RIGHT",
"ACT_MP_MANTLE_CROUCH_ABOVE",
"ACT_MP_MANTLE_CROUCH_LEVEL",
"ACT_MP_MANTLE_CROUCH_BELOW",
"ACT_MP_MANTLE_HIGH",
"ACT_MP_LOOT_IDLE_STAND",
"ACT_MP_EQUIP_FROM_ROCKET_TO_PISTOL",
"ACT_MP_EQUIP_FROM_ROCKET_TO_RIFLE",
"ACT_MP_EQUIP_FROM_ROCKET_TO_ROCKET",
"ACT_MP_DOWNED_IDLE",
"ACT_TRANSITION_TO_STANDING_FROM_DOWNED",
"ACT_TRANSITION_TO_DOWNED_FROM_STANDING",
"ACT_MP_LOOT_IDLE_CROUCH",
"ACT_MP_DOWNED_CRAWL_LEFT",
"ACT_MP_DOWNED_CRAWL_BACKWARD",
"ACT_MP_DOWNED_CRAWL_FORWARD",
"ACT_MP_DOWNED_CRAWL",
"ACT_MP_MENU_LOBBY_RIGHT_IDLE",
"ACT_MP_MENU_LOBBY_CENTER_IDLE",
"ACT_MP_MENU_LOBBY_LEFT_IDLE",
"ACT_MP_DOWNED_CRAWL_RIGHT",
"ACT_MP_OFFHAND_CHARGING_ALT_1",
"ACT_MP_OFFHAND_CHARGING",
"ACT_MP_OFFHAND_FIRE",
"ACT_MP_OFFHAND_END",
"ACT_MP_MELEE",
"ACT_MP_OFFHAND_CHARGING_ALT_4",
"ACT_MP_OFFHAND_CHARGING_ALT_3",
"ACT_MP_OFFHAND_CHARGING_ALT_2",
"ACT_MP_EQUIP_FROM_RIFLE_TO_PISTOL",
"ACT_MP_EQUIP_FROM_RIFLE_TO_RIFLE",
"ACT_MP_MELEE_KNIFE",
"ACT_MP_MELEE_KNIFE_FIRST",
"ACT_MP_EQUIP_FROM_PISTOL_TO_ROCKET",
"ACT_MP_EQUIP_FROM_PISTOL_TO_RIFLE",
"ACT_MP_EQUIP_FROM_PISTOL_TO_PISTOL",
"ACT_MP_EQUIP_FROM_RIFLE_TO_ROCKET",
"ACT_MP_JUMP_START_PRIMARY",
"ACT_MP_JUMP_PRIMARY",
"ACT_MP_CROUCHWALK_PRIMARY",
"ACT_MP_AIRWALK_PRIMARY",
"ACT_MP_STAND_SECONDARY",
"ACT_MP_DEPLOYED_PRIMARY",
"ACT_MP_JUMP_LAND_PRIMARY",
"ACT_MP_JUMP_FLOAT_PRIMARY",
"ACT_MP_RUN_MELEE",
"ACT_MP_CROUCH_MELEE",
"ACT_MP_STAND_MELEE",
"ACT_MP_RUN_SECONDARY",
"ACT_MP_JUMP_MELEE",
"ACT_MP_CROUCHWALK_MELEE",
"ACT_MP_AIRWALK_MELEE",
"ACT_MP_WALK_MELEE",
"ACT_MP_MENU_READYUP_INTRO",
"ACT_MP_MENU_MAIN_IDLE",
"ACT_MP_MENU_MAIN_INTRO",
"ACT_MP_MENU_LOBBY_SELECT_IDLE",
"ACT_MP_MENU_SQUAD_IDLE",
"ACT_MP_MENU_DETAILS_IDLE",
"ACT_MP_MENU_DETAILS_INTRO",
"ACT_MP_MENU_READYUP_IDLE",
"ACT_MP_MENU_LOOT_CEREMONY_IDLE",
"ACT_MP_MENU_GROUPSHOT_SLOT_C",
"ACT_MP_MENU_GROUPSHOT_SLOT_B",
"ACT_MP_MENU_GROUPSHOT_SLOT_A",
"ACT_MP_WALK_PRIMARY",
"ACT_MP_RUN_PRIMARY",
"ACT_MP_CROUCH_PRIMARY",
"ACT_MP_STAND_PRIMARY",
"ACT_MP_DEATH_RUN_RIGHT",
"ACT_MP_DEATH_RUN_LEFT",
"ACT_MP_DEATH_RUN_BACKWARD",
"ACT_MP_DEATH_RUN_FORWARD",
"ACT_MP_DROWNING_PRIMARY",
"ACT_MP_RUN_SPEEDPAINT_PRIMARY",
"ACT_MP_DEATH_SPRINT_FORWARD",
"ACT_MP_DEATH_SPRINT",
"ACT_MP_DEATH_CRUSH_PRIMARY",
"ACT_MP_TRACTORBEAM_FLOAT_PRIMARY",
"ACT_MP_LONG_FALL_PRIMARY",
"ACT_MP_GESTURE_FLINCH_BACKWARDS",
"ACT_MP_JUMP_LAND_MELEE",
"ACT_MP_JUMP_FLOAT_MELEE",
"ACT_MP_JUMP_START_MELEE",
"ACT_MP_DEATH_CRUSH",
"ACT_MP_GESTURE_FLINCH_RIGHT",
"ACT_MP_GESTURE_FLINCH_FORWARDS",
"ACT_MP_GESTURE_FLINCH_LEFT",
"ACT_MP_DEATH_WALK_FORWARD",
"ACT_MP_DEATH_WALK",
"ACT_MP_DEATH_CROUCH",
"ACT_MP_DEATH_GENERIC",
"ACT_MP_DEATH_RUN",
"ACT_MP_DEATH_WALK_RIGHT",
"ACT_MP_DEATH_WALK_LEFT",
"ACT_MP_DEATH_WALK_BACKWARD"]

void function DEV_SpawnExplosiveTickAtCrosshair()
{
	entity player = GetPlayerArray()[ 0 ]

	vector origin = GetPlayerCrosshairOrigin( player )
	vector angles = Vector( 0, 0, 0 )

	entity tick = CreateFragDrone( 99, origin, angles )

	DispatchSpawn( tick )
	tick.SetSkin(RandomInt(2))
}

void function DEV_SpawnAllNPCsWithTeam( int team )
{
	printt( "script thread DEV_SpawnAllNPCsWithTeam( " + team + " )" )
	Assert( IsNewThread(), "Must be threaded off due to precache issues" )
	bool restoreHostThreadMode = GetConVarInt( "host_thread_mode" ) != 0
	if ( restoreHostThreadMode )
	{
		DisablePrecacheErrors()
		wait 0.5
	}

	entity player = GetPlayerArray()[ 0 ]
	vector origin = GetPlayerCrosshairOrigin( player )
	array<string> aiSettings = GetAllNPCSettings()

	foreach ( settings in aiSettings )
	{
		vector angles = < 0, RandomFloat( 360 ), 0 >
		entity npc = CreateNPCFromAISettings( settings, team, origin, angles )
		DispatchSpawn( npc )
	}

	if ( restoreHostThreadMode )
	{
		wait 0.2
		RestorePrecacheErrors()
	}
}

void function DEV_SpawnWeaponAtCrosshair( string weaponName )
{
	printt( "script thread DEV_SpawnWeaponAtCrosshair( \"" + weaponName + "\")" )

	Assert( IsNewThread(), "Must be threaded off due to precache issues" )

	entity player = GetPlayerArray()[ 0 ]
	if ( !IsValid( player ) )
		return
	vector origin = GetPlayerCrosshairOrigin( player )
	vector angles = Vector( 0, 0, 0 )
	entity weapon = CreateWeaponEntityByNameWithPhysics( weaponName, origin, angles )

#if SP
	bool isTitanWeapon = weaponName.find( "mp_titanweapon_" ) != null
	if ( isTitanWeapon )
		thread TitanLoadoutWaitsForPickup( weapon, SPTitanLoadoutPickup )
#endif
}

function SetAISettingsWrapper( entity npc, string settings )
{
	npc.SetAISettings( settings )
	Assert( settings.find( npc.GetClassName() ) == 0, "NPC classname " + npc.GetClassName() + " not found in " + settings )

	if ( IsSingleplayer() )
	{
		FixupTitle( npc )
	}
}

bool function WithinEngagementRange( entity npc, vector origin )
{
	entity weapon = npc.GetActiveWeapon( eActiveInventorySlot.mainHand )
	if ( weapon == null )
		return false

	float dist = Distance( npc.GetOrigin(), origin )
	if ( dist < weapon.GetWeaponInfoFileKeyField( "npc_min_engage_range" ) )
		return false

	return dist <= weapon.GetWeaponInfoFileKeyField( "npc_max_engage_range" )
}