//WorldDraw Registration of server/client assets 							//mkos
//Todo: Assign desired assets in a timely manner based on streamed rpaks success

global function WorldDrawAsset_RegisterAllAssets

#if CLIENT
	global function ClientCodeCallback_PakRequestFinished //todo: move?
	global function ServerCallback_ShouldWaitForRpak
	global function VideoExists
#endif

#if SERVER 
	global function WorldDrawAsset_GetInvalid
	global function WorldDrawAsset_TransmitDesiredAssets
#endif 

const MAX_WAIT_FOR_RPAK_TRANSFER = 5
const RPAK_MP_TEMP_PATH = ""

struct
{
	//these must match on server/client ( until a transfer sdk implemention this is static )
	array<string> assets = 
	[
		"rui/flowstate_custom/mkos/1v1banner",
		"media/respawn.bik",
		"rui/world/flowstate1v1_banner01",
		"rui/world/flowstate1v1_banner02",
		"rui/world/flowstate1v1_rdiffs",
		"rui/world/flowstate1v1_banner03",
		"rui/world/karma_banner_01",
		"rui/balls_image",
		"balls.bik",
		"media/karma-r5r-video.bik",
	]
	
	#if SERVER 
		array<int> invalidAssets
	#endif 
	
	#if CLIENT
		bool bShouldWaitForRpak = false
		string someRpakName = ""
		array<string> someBuiltAssetArrayFromServerClientMightNotHave = []
		array<int> invalidVideoAssets
		bool videoValidationComplete = false
	#endif

} file

void function WorldDrawAsset_RegisterAllAssets()
{
	#if SERVER 
		AddClientCommandCallback( "assetIntegrityCheck", ClientCommand_AssetIntegrityCheck )
	#endif
	
	#if CLIENT 
		if( file.bShouldWaitForRpak )
		{
			WorldDrawAsset_SetupRequestedAssets( file.someRpakName, file.someBuiltAssetArrayFromServerClientMightNotHave )
			waitthread WaitSignalOrTimeout( GetLocalClientPlayer(), 7, "RemoteAssetsLoaded" )	
		}
		
		array<int> invalidAssets = []
		array<int> videoAssetsToCheck = []
	#endif
	
	int iter = -1
	foreach( potentialVarAsset in file.assets )
	{	
		++iter
		int assetType = -1
		
		//chain ifelse for more types.
		if( potentialVarAsset.find( ".bik" ) != -1 )
			assetType = eAssetType.VIDEO
		else 
			assetType = eAssetType.IMAGE
		
		#if CLIENT		
			switch( assetType )
			{
				case eAssetType.IMAGE:
				
					if( !RuiImageExists( potentialVarAsset ) )
						invalidAssets.append( iter )
				break 
				
				case eAssetType.VIDEO:
					
					videoAssetsToCheck.append( iter ) 
				break 
			}		
		#endif
		
		asset varAsset
		varAsset = CastStringToAsset( potentialVarAsset )
		
		WorldDrawAsset_RegisterRemoteAsset( varAsset, assetType )
	}
	
	#if CLIENT 
		thread
		(
			void function() : ( invalidAssets, videoAssetsToCheck )
			{					
				FlagWait( "EntitiesDidLoad" )
				
				entity player = GetLocalClientPlayer()
				if( !IsValid( player ) )
					return
				
				CheckVideoAssets_expensive( player, videoAssetsToCheck ) //was: waitthread
				invalidAssets.extend( file.invalidVideoAssets )
				
				string cmd
				foreach( inv in invalidAssets )
					cmd += " " + string( inv )
				
				if( !IsValid( player ) ) //waited for thread, recheck.
					return
					
				//this client command is responsible for letting the server know 
				// what assets are not available on the client. IMPORTANT.
				player.ClientCommand( "assetIntegrityCheck" + cmd )
				file.videoValidationComplete = true
			}
		)()
	#endif
}

#if SERVER 
	array<int> function WorldDrawAsset_GetInvalid()
	{
		return file.invalidAssets
	}
#endif 

#if CLIENT
	void function ClientCodeCallback_PakRequestFinished( table preferablyTableOfSomedata ) //todo: move
	{
		entity player = GetLocalClientPlayer()
		player.Signal( "PakReadyForLoad", preferablyTableOfSomedata )
	}
	
	void function ServerCallback_ShouldWaitForRpak( bool setting )
	{
		file.bShouldWaitForRpak = setting
	}
	
	void function WorldDrawAsset_SetupRequestedAssets( string rpakName, array<string> assetList )
	{
		thread
		(
			function() : ( rpakName, assetList )
			{
				entity player = GetLocalClientPlayer()
				player.EndSignal( "OnDestroy", "OnDisconnected" )
		
				float startTime = Time()
				
				while( !IsDownloadedFileReadyForPakLoad( rpakName ) )
				{
					if( Time() - startTime > MAX_WAIT_FOR_RPAK_TRANSFER )
					{
						break
					}
					
					WaitFrame()
				}
				
				if( !IsDownloadedFileReadyForPakLoad( rpakName ) )
				{
					#if DEVELOPER 
						Warning( "Warning: Failed to get pak " + rpakName + " in time" )
					#endif 
					
					return
				}
				
				int handle = ClientPakFile_RequestAsyncLoad( RPAK_MP_TEMP_PATH + rpakName )	
				
				if( handle == -1 )
					return
				
				table result = player.WaitSignal( "PakReadyForLoad" )
				
				//will need a better impl to avoid sync issues
				//currently this would assume we aren't going to fire multiple
				//pakready signals which is naive and this code is only valid
				//for testing purposes
				
				if( result.success == null || result.handle == null )
					return
				
				if( expect bool( result.success ) && expect int( result.handle ) == handle ) 
				{
					file.assets.extend( assetList )
					player.Signal( "RemoteAssetsLoaded" )
				} 
			}
		)()		
	}
	
	//There really is no other way to validate if a video exists on the client. Sorry.
	void function CheckVideoAssets_expensive( entity player, array<int> videoAssetIds )
	{
		if( !IsValid( player ) ) //check again, was threaded off.
			return
			
		EndSignal( player, "OnDestroy" )
		int channel = ReserveVideoChannel()
		
		foreach( assetId in videoAssetIds )
		{
			asset video = WorldDrawAsset_GetAssetByID( assetId )
			StartVideoOnChannel( channel, video, false, 0.0 )
			PauseVideoOnChannel( channel )
			
			WaitFrames(3)
			
			// please don't remove this debug comment. Thanks ~mkos.
			
			// int frames
			// while( !VideoChannelHasVideoAssigned( channel ) )
			// {
				// ++frames
				// printw( "current frame=", frames )
				// WaitFrame()
			// }
			
			// printw( "Total frames needed to detect video =", frames )
			// DEV_SetBreakPoint()
			
			if( !VideoChannelHasVideoAssigned( channel ) )
			{	
				#if DEVELOPER
					printw( "Video asset:", string( video ), "is not valid! id = ", assetId )
				#endif 
				
				file.invalidVideoAssets.append( assetId )
			}
			
			StopVideoOnChannel( channel )
		}
		
		ReleaseVideoChannel( channel )
	}
	
	bool function VideoExists( int assetId )
	{
		if( !file.videoValidationComplete )
			mAssert( false, "Tried to check if video exists before validator has ran." )
			
		return file.invalidVideoAssets.contains( assetId )
	}
#endif

#if SERVER	
	void function WorldDrawAsset_TransmitDesiredAssets()
	{
		// Append desired assets to server list, omitting duplicates
		// Fire RemoteCall to notify client it should load rpaks if using
		// And extend asset list before proceeding to init
		
		// The client will not have these always, so :
		// Implement call and checks to transfer rpak containing assets via code
		// Transmit an array of asset image string refs desired to be loaded into WorldDraw framework
	}
	
	bool function ClientCommand_AssetIntegrityCheck( entity player, array<string> args )
	{
		if( !IsValid( player ) )
			return false
			
		string signal = "BannersValidated"
		
		if( args.len() < 1 )
		{
			player.p.bannersValidated = true
			player.Signal( signal )
			return true
		}
			
		array<int> invalidAssets
		foreach( arg in args )
		{
			if( !IsNumeric( arg, 0, 99999 ) )
				continue
			
			invalidAssets.append( int( arg ) )
		}
		
		player.p.invalidAssets.extend( invalidAssets )
		player.p.bannersValidated = true
		
		player.Signal( signal )
		return true
	}
#endif