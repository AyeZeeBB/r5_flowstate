//WorldDraw Registration of server/client assets 							//mkos
//Todo: Assign desired assets in a timely manner based on streamed rpaks success

global function WorldDrawAsset_RegisterAllAssets

#if CLIENT
	global function ClientCodeCallback_PakRequestFinished //todo: move?
	global function ServerCallback_ShouldWaitForRpak
#endif

#if SERVER 
	global function WorldDrawAsset_GetInvalid
	global function WorldDrawAsset_TransmitDesiredAssets
#endif 

const MAX_WAIT_FOR_RPAK_TRANSFER = 5
const RPAK_MP_TEMP_PATH = ""

struct
{
	//these must match on server/client ( until a transfer sdk implemention this is static )
	array<string> assets = 
	[
		"rui/flowstate_custom/mkos/1v1banner",
		"media/respawn.bik",
		"rui/world/flowstate1v1_banner01",
		"rui/world/flowstate1v1_banner02",
		"rui/world/flowstate1v1_rdiffs",
		"rui/world/flowstate1v1_banner03",
		"rui/world/karma_banner_01"
		//"media/karma-r5r-video.bik",
	]
	
	#if SERVER 
		array<int> invalidAssets
	#endif 
	
	#if CLIENT
		bool bShouldWaitForRpak = false
		string someRpakName = ""
		array<string> someBuiltAssetArrayFromServerClientMightNotHave = []
	#endif 

} file

void function WorldDrawAsset_RegisterAllAssets()
{
	#if SERVER 
		AddClientCommandCallback( "assetIntegrityCheck", ClientCommand_AssetIntegrityCheck )
	#endif
	
	#if CLIENT 
		if( file.bShouldWaitForRpak )
		{
			WorldDrawAsset_SetupRequestedAssets( file.someRpakName, file.someBuiltAssetArrayFromServerClientMightNotHave )
			waitthread WaitSignalOrTimeout( GetLocalClientPlayer(), 7, "RemoteAssetsLoaded" )	
		}
		
		array<int> invalidAssets = []
	#endif
	
	int iter = -1
	foreach( potentialVarAsset in file.assets )
	{	
		++iter
		int assetType = -1
		
		//chain ifelse for more types.
		if( potentialVarAsset.find( ".bik" ) != -1 )
			assetType = eAssetType.VIDEO
		else 
			assetType = eAssetType.IMAGE
		
		#if CLIENT	
			//todo: determine if bik exists? NEED A WAY?!
			if( assetType == eAssetType.IMAGE && !RuiImageExists( potentialVarAsset ) )
			{
				invalidAssets.append( iter )
			}
		#endif
		
		asset varAsset
		
		try
		{
			varAsset = CastStringToAsset( potentialVarAsset ) //never fails apparently		
		}
		catch( e )
		{
			#if DEVELOPER
				Warning( "Error: " + e )
			#endif 
			
			#if CLIENT
				invalidAssets.append( iter )
			#elseif SERVER 
				file.invalidAssets.append( iter )
			#endif
		}
		
		WorldDrawAsset_RegisterRemoteAsset( varAsset, assetType )
	}
	
	#if CLIENT 
		thread
		(
			void function() : ( invalidAssets )
			{	
				string cmd
				foreach( inv in invalidAssets )
					cmd += " " + string( inv )
					
				FlagWait( "EntitiesDidLoad" )
				entity player = GetLocalClientPlayer()
				if( !IsValid( player ) )
					return
					
				player.ClientCommand( "assetIntegrityCheck" + cmd )
			}
		)()
	#endif
}

#if SERVER 
	array<int> function WorldDrawAsset_GetInvalid()
	{
		return file.invalidAssets
	}
#endif 

#if CLIENT
	void function ClientCodeCallback_PakRequestFinished( table preferablyTableOfSomedata ) //todo: move
	{
		entity player = GetLocalClientPlayer()
		player.Signal( "PakReadyForLoad", preferablyTableOfSomedata )
	}
	
	void function ServerCallback_ShouldWaitForRpak( bool setting )
	{
		file.bShouldWaitForRpak = setting
	}
	
	void function WorldDrawAsset_SetupRequestedAssets( string rpakName, array<string> assetList )
	{
		thread
		(
			function() : ( rpakName, assetList )
			{
				entity player = GetLocalClientPlayer()
				player.EndSignal( "OnDestroy", "OnDisconnected" )
		
				float startTime = Time()
				
				while( !IsDownloadedFileReadyForPakLoad( rpakName ) )
				{
					if( Time() - startTime > MAX_WAIT_FOR_RPAK_TRANSFER )
					{
						break
					}
					
					WaitFrame()
				}
				
				if( !IsDownloadedFileReadyForPakLoad( rpakName ) )
				{
					#if DEVELOPER 
						Warning( "Warning: Failed to get pak " + rpakName + " in time" )
					#endif 
					
					return
				}
				
				int handle = ClientPakFile_RequestAsyncLoad( RPAK_MP_TEMP_PATH + rpakName )	
				
				if( handle == -1 )
					return
				
				table result = player.WaitSignal( "PakReadyForLoad" )
				
				//will need a better impl to avoid sync issues
				//currently this would assume we aren't going to fire multiple
				//pakready signals which is naive and this code is only valid
				//for testing purposes
				
				if( result.success == null || result.handle == null )
					return
				
				if( expect bool( result.success ) && expect int( result.handle ) == handle ) 
				{
					file.assets.extend( assetList )
					player.Signal( "RemoteAssetsLoaded" )
				} 
			}
		)()
		
	}
#endif

#if SERVER	
	void function WorldDrawAsset_TransmitDesiredAssets()
	{
		// Append desired assets to server list, omitting duplicates
		// Fire RemoteCall to notify client it should load rpaks if using
		// And extend asset list before proceeding to init
		
		// The client will not have these always, so :
		// Implement call and checks to transfer rpak containing assets via code
		// Transmit an array of asset image string refs desired to be loaded into WorldDraw framework
	}
	
	bool function ClientCommand_AssetIntegrityCheck( entity player, array<string> args )
	{
		if( !IsValid( player ) )
			return false
			
		string signal = "BannersValidated"
		
		if( args.len() < 1 )
		{
			player.p.bannersValidated = true
			player.Signal( signal )
			return true
		}
			
		array<int> invalidAssets
		foreach( arg in args )
		{
			if( !IsNumeric( arg, 0, 99999 ) )
				continue
			
			invalidAssets.append( int( arg ) )
		}
		
		player.p.invalidAssets.extend( invalidAssets )
		player.p.bannersValidated = true
		
		player.Signal( signal )
		return true
	}
#endif